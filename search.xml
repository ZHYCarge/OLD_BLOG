<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 后台运行</title>
    <url>/2021/07/14/Hexo-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于需要hexo-damin支持编写博客，所以需要将hexo服务进行一直开启，但是由于ssh有相关连接限制，又不想修改ssh配置文件，所以出此博客</p>
<span id="more"></span>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="安装pm2模块"><a href="#安装pm2模块" class="headerlink" title="安装pm2模块"></a>安装pm2模块</h2><h3 id="什么是pm2模块"><a href="#什么是pm2模块" class="headerlink" title="什么是pm2模块"></a>什么是pm2模块</h3><p>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。 下面就对PM2进行入门性的介绍，基本涵盖了PM2的常用的功能和配置。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>输入指令<br><code> npm  install -g pm2</code>来进行安装</p>
<h2 id="在博客根目录下创建run-js文件"><a href="#在博客根目录下创建run-js文件" class="headerlink" title="在博客根目录下创建run.js文件"></a>在博客根目录下创建<code>run.js</code>文件</h2><p>在博客根目录下创建一个<code>run.js</code>的文件，并在里面输入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//将hexo保持后台运行</span><br><span class="line">const &#123; <span class="built_in">exec</span> &#125; = require(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;hexo server&#x27;</span>,(error, stdout, stderr) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(error)&#123;</span><br><span class="line">                console.log(<span class="string">&#x27;exec error: $&#123;error&#125;&#x27;</span>)</span><br><span class="line">                <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        console.log(<span class="string">&#x27;stdout: $&#123;stdout&#125;&#x27;</span>);</span><br><span class="line">        console.log(<span class="string">&#x27;stderr: $&#123;stderr&#125;&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="之后在根目录下运行"><a href="#之后在根目录下运行" class="headerlink" title="之后在根目录下运行"></a>之后在根目录下运行</h2><p>输入：<code>pm2 start run.js </code></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如何关停pm2"><a href="#如何关停pm2" class="headerlink" title="如何关停pm2"></a>如何关停pm2</h2><p>输入<code>pm2 stop all</code>来关停所有的pm2运行项目</p>
<h2 id="pm2相关命令汇总"><a href="#pm2相关命令汇总" class="headerlink" title="pm2相关命令汇总"></a>pm2相关命令汇总</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">pm2 <span class="literal">start</span> app.js <span class="comment"># 启动app.js应用程序</span></span><br><span class="line"> pm2 <span class="literal">start</span> app.js -i <span class="number">4</span> <span class="comment"># cluster mode 模式启动4个app.js的应用实例</span></span><br><span class="line"><span class="comment"># 4个应用程序会自动进行负载均衡</span></span><br><span class="line"> pm2 <span class="literal">start</span> app.js --<span class="attr">name=</span><span class="string">&quot;api&quot;</span> <span class="comment"># 启动应用程序并命名为 &quot;api&quot;</span></span><br><span class="line"> pm2 <span class="literal">start</span> app.js --watch <span class="comment"># 当文件变化时自动重启应用</span></span><br><span class="line"> pm2 <span class="literal">start</span> script.sh <span class="comment"># 启动 bash 脚本</span></span><br><span class="line"></span><br><span class="line"> pm2 list <span class="comment"># 列表 PM2 启动的所有的应用程序</span></span><br><span class="line"> pm2 monit <span class="comment"># 显示每个应用程序的CPU和内存占用情况</span></span><br><span class="line"> pm2 show [app-name] <span class="comment"># 显示应用程序的所有信息</span></span><br><span class="line"></span><br><span class="line"> pm2 logs <span class="comment"># 显示所有应用程序的日志</span></span><br><span class="line"> pm2 logs [app-name] <span class="comment"># 显示指定应用程序的日志</span></span><br><span class="line">pm2 flush</span><br><span class="line"></span><br><span class="line"> pm2 <span class="literal">stop</span> all <span class="comment"># 停止所有的应用程序</span></span><br><span class="line"> pm2 <span class="literal">stop</span> <span class="number">0</span> <span class="comment"># 停止 id为 0的指定应用程序</span></span><br><span class="line"> pm2 restart all <span class="comment"># 重启所有应用</span></span><br><span class="line"> pm2 reload all <span class="comment"># 重启 cluster mode下的所有应用</span></span><br><span class="line"> pm2 gracefulReload all <span class="comment"># Graceful reload all apps in cluster mode</span></span><br><span class="line"> pm2 delete all <span class="comment"># 关闭并删除所有应用</span></span><br><span class="line">pm2 delete <span class="number">0</span> <span class="comment"># 删除指定应用 id 0</span></span><br><span class="line"> pm2 scale api <span class="number">10</span> <span class="comment"># 把名字叫api的应用扩展到10个实例</span></span><br><span class="line"> pm2 reset [app-name] <span class="comment"># 重置重启数量</span></span><br><span class="line"></span><br><span class="line"> pm2 startup <span class="comment"># 创建开机自启动命令</span></span><br><span class="line"> pm2 save <span class="comment"># 保存当前应用列表</span></span><br><span class="line"> pm2 resurrect <span class="comment"># 重新加载保存的应用列表</span></span><br><span class="line"> pm2 update <span class="comment"># Save processes, kill PM2 and restore processes</span></span><br><span class="line"> pm2 generate <span class="comment"># Generate a sample json configuration file</span></span><br><span class="line">pm2 <span class="literal">start</span> app.js --<span class="keyword">node</span><span class="title">-args</span>=<span class="string">&quot;--max-old-space-size=1024&quot;</span></span><br><span class="line"></span><br><span class="line">作者：冰冰大象</span><br><span class="line">链接：https://www.jianshu.com/p/<span class="number">6</span>b3b506f7d0a</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下如何挂载磁盘[Arch系统]</title>
    <url>/2021/07/12/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98-Arch%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>嫌弃开机后要自己手动挂载，不是懒人的亚子，因此。。。<br><strong>请注意：此教程会对电脑系统配置文件进行修改，如果操作时出现问题，可能会导致电脑无法开启，请认真观看</strong></p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h2><p>首先，我们应当查询一下自己的挂载点，或者是自己设置一个挂载信息，为了方便，我会在配置前，手动将磁盘进行挂载，方便后面获取信息</p>
<h2 id="查询自己的盘符信息"><a href="#查询自己的盘符信息" class="headerlink" title="查询自己的盘符信息"></a>查询自己的盘符信息</h2><p>需要挂载硬盘，那么我们应当首先知道，硬盘的一些信息<br>因此我们需要输入<code>lsblk -o +UUID,fstype</code>命令，来查询一下我们的硬盘信息<br><img src="https://img-blog.csdnimg.cn/20210702235004557.png" alt="122"><br>以上是显示的信息，当然不全，后面资料涉及电脑隐私，不方便展示<br>我们需要知道磁盘的UUID，然后磁盘的挂载位置（MOUNTPOINTS）然后还有磁盘的类别（FSTYPE）</p>
<h2 id="更改磁盘挂载信息"><a href="#更改磁盘挂载信息" class="headerlink" title="更改磁盘挂载信息"></a>更改磁盘挂载信息</h2><p>知道以上信息之后，我们需要修改相关配置文件，之后我们在终端中输入<code>sudo vim /etc/fstab</code>来进行修改电脑配置文件<br><img src="https://img-blog.csdnimg.cn/20210702235635108.png" alt="1221"><br>然后我们会获得下述信息<br>我们需要在下方输入如下内容：<br><img src="https://img-blog.csdnimg.cn/20210702235818325.png" alt="1212"><br>按照上面查找的内容，输入信息（空格随意，最好要有区分度）<br>UUID为上面查询的内容，挂载位置为上文查询的MOUNTPOINTS，磁盘类型是上文的FSTYPE，相关选项一般填写defaults（默认），后面那个一般填写0  2<br>最后检查一下你的填写信息，就可以保存退出，之后重启电脑试验了</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>当你不确定你填写信息是否正确的时候，可以将defaults修改成<code>nofail,x-systemd.device-timeout=1ms</code>这样的话，当系统在1ms内无法挂载你的磁盘的时候，就会放弃本次挂载，继续启动，但是要是重要的系统盘为进行挂载的话，也会出现问题</p>
<h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>请注意：本次教程只针对对于系统可以成功进入，相关盘符可以直接挂载的人使用的，如果是系统盘，则需要根据官方文档来进行操作</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Arduino安装教程</title>
    <url>/2021/07/14/esp8266%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下自己安装Arduino的心路历程以及相关过程</p>
<span id="more"></span>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="什么是Arduino"><a href="#什么是Arduino" class="headerlink" title="什么是Arduino"></a>什么是Arduino</h2><blockquote>
<p>Arduino是一款便捷灵活、方便上手的开源电子原型平台。包含硬件（各种型号的Arduino板）和软件（IDE）。Arduino能通过各种各样的传感器来感知环境，通过控制灯光、马达和其他的装置来反馈、影响环境。它有着高度分装，方便调用的代码，可以和各类传感器轻松互动，实现我们的创客梦想！<br>知乎  </p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于此软件由国外开发者所开发，因此软件的安装包也在国外地区，不过国内团队已经提供了一个比较好的安装平台为大家进行选择<br><a href="http://www.taichi-maker.com/homepage/download/#software-download">点我</a><br>通过这个方式，能够很好的下载IDE</p>
<h2 id="配置esp8266的环境"><a href="#配置esp8266的环境" class="headerlink" title="配置esp8266的环境"></a>配置esp8266的环境</h2><p>由于编写是为了编写esp8266，因此我们需要配置它的环境<br>点击<kbd>文件</kbd>—&gt;<kbd>首选项</kbd>，在后面<kbd>附加开发板管理器网址</kbd>处输入以下内容：<br><code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code> 或<br><code>http://wechat.doit.am/package_esp8266com_index.json</code></p>
<p><img src="/images/pasted-8.png" alt="upload successful"></p>
<p><img src="/images/pasted-9.png" alt="upload successful"></p>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<blockquote>
<p>博主小提醒：<br>由于配置时也是参考了别人的博客，因此测试了一下这两个，发现：<br>第一个需要翻墙进行访问（但是是官方的，会比国内的要很多,虽然会很慢，但是推荐）<br>第二个好像资源已经被删除或者被移动到了其他的地方，将文件地址输入到网站上会显示404界面<br>因此博主采用直接下载的方法进行安装</p>
</blockquote>
<p>之后对ide进行重启。之后我们点击<kbd>工具</kbd>—&gt;<kbd>开发板</kbd>—&gt;<kbd>开发板管理器</kbd><br>，在界面中输入esp8266进行搜索安装</p>
<p><img src="/images/pasted-12.png" alt="upload successful"></p>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
<p><img src="/images/pasted-14.png" alt="upload successful"></p>
<p>如果发生安装失败的方法，可以看上文，并<a href="#wrong1">点击我来进行跳转</a><br>之后便是重新启动ide软件，会发现esp8266的相关库已经安装成功了</p>
<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<h1 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h1><h2 id="通过博客流程无法正常安装esp8266相关库"><a href="#通过博客流程无法正常安装esp8266相关库" class="headerlink" title="通过博客流程无法正常安装esp8266相关库"></a><div id="wrong1">通过博客流程无法正常安装esp8266相关库</div></h2><p>这里提供一个链接，通过<a href="https://www.arduino.cn/thread-76029-1-1.html">点我</a>来进行下载由大佬<code>奈何col</code>所提供的源码。[请注意，此版本为esp8266 2.7版本]<br>下载完成之后双击安装即可</p>
<h2 id="安装完包之后发现有更新，点击之后相关库消失了"><a href="#安装完包之后发现有更新，点击之后相关库消失了" class="headerlink" title="安装完包之后发现有更新，点击之后相关库消失了"></a>安装完包之后发现有更新，点击之后相关库消失了</h2><p>建议安装完第三方库不要进行更新，因为可能会出现库的匹配问题，有一定几率会删除之前安装的库</p>
<h2 id="安装过程报错"><a href="#安装过程报错" class="headerlink" title="安装过程报错"></a>安装过程报错</h2><p>这种情况在安装的时候我也出现过，解决方法就是多次点击安装，可能会出现的错误有<code>未通过验证</code>或者<code>在github上未找到相关包</code></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如有其他问题，欢迎留言</p>
]]></content>
      <categories>
        <category>study</category>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>esp8266</tag>
      </tags>
  </entry>
  <entry>
    <title>git的相关代码</title>
    <url>/2021/07/12/git%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从自己csdn上搬过来的，比较有用的</p>
<span id="more"></span>
<h3 id="本地相关操作"><a href="#本地相关操作" class="headerlink" title="本地相关操作"></a>本地相关操作</h3><h4 id="基操"><a href="#基操" class="headerlink" title="基操"></a>基操</h4><ul>
<li>添加工作区文件到暂存区</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">git <span class="title">add</span> <span class="params">(文件名称/./--all/-a)</span></span></span><br><span class="line"><span class="function">其中第一个为添加指定文件到暂存区，后面三个是添加当前根目录下全部文件到暂存区</span></span><br></pre></td></tr></table></figure>

<ul>
<li>暂存区文件提交到版本库</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交信息内容&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前根目录下文件状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前仓库内版本记录</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> --graph			有图形界面</span><br><span class="line">git <span class="built_in">log</span> --graph --pretty=format:<span class="string">&quot;%h %s&quot;</span>		</span><br><span class="line">在图形界面的基础上简化显示，只显示版本号以及提交信息</span><br></pre></td></tr></table></figure>

<ul>
<li>回滚文件到之前版本</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号</span><br><span class="line">PS：版本号用git <span class="built_in">log</span>查看</span><br></pre></td></tr></table></figure>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><ul>
<li>查看分支</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<ul>
<li>创建分支</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git branch 分支名称</span><br></pre></td></tr></table></figure>

<ul>
<li>切换分支</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git checkout 分支名称</span><br></pre></td></tr></table></figure>

<ul>
<li>删除分支</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git branch -d 分支名称</span><br></pre></td></tr></table></figure>

<ul>
<li>合并分支（将别的分支合并到当前分支）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git merge 需要合并过来的分支</span><br></pre></td></tr></table></figure>

<h3 id="云端操作"><a href="#云端操作" class="headerlink" title="云端操作"></a>云端操作</h3><h4 id="基操-1"><a href="#基操-1" class="headerlink" title="基操"></a>基操</h4><ul>
<li>云端克隆仓库到本地</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git clone 仓库SSH地址</span><br></pre></td></tr></table></figure>

<ul>
<li>更新本地仓库（从云端信息）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git pull origin 分支名称</span><br></pre></td></tr></table></figure>

<ul>
<li>将版本库的版本上传到云端</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<ul>
<li>从远程仓库获取文件到版本区</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git fetch origin 分支</span><br></pre></td></tr></table></figure>

<ul>
<li>将版本库的代码提取到工作区</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git merge origin/分支</span><br></pre></td></tr></table></figure>

<h4 id="创建一个新的本地仓库并且送到云端"><a href="#创建一个新的本地仓库并且送到云端" class="headerlink" title="创建一个新的本地仓库并且送到云端"></a>创建一个新的本地仓库并且送到云端</h4><ol>
<li>在本地创建一个新的仓库</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git init </span><br><span class="line">PS：进入目标文件夹之后进行</span><br></pre></td></tr></table></figure>

<p>2.添加文件到暂存区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">git <span class="title">add</span> <span class="params">(文件名称)</span></span></span><br></pre></td></tr></table></figure>

<p>3.链接本地仓库以及远程仓库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git renmote add origin 远程地址</span><br><span class="line">PS：origin 好像可以改成随意的，但是以后的相关操作也需要变化</span><br></pre></td></tr></table></figure>
<p>4.暂存区文件到版本区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;相关描述&quot;</span></span><br></pre></td></tr></table></figure>
<p>5.上传文件到相关分支</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br><span class="line">PS：-u可以不需要加（暂时没研究不加以及加的区别）</span><br><span class="line">PPS:master 上传到远程仓库的主分支，这个可以换成其他的</span><br></pre></td></tr></table></figure>
<h4 id="本地已经有仓库"><a href="#本地已经有仓库" class="headerlink" title="本地已经有仓库"></a>本地已经有仓库</h4><p>本地有仓库需要提交到云端的话只需要执行上面的3、5两个步骤即可</p>
<h4 id="git取消与远程仓库的的连接"><a href="#git取消与远程仓库的的连接" class="headerlink" title="git取消与远程仓库的的连接"></a>git取消与远程仓库的的连接</h4><p>连接远程仓库<br><code>git remote add origin 仓库地址</code></p>
<p>查看远程连接<br><code>git remote -v</code></p>
<p>git取消与远程仓库的连接<br><code>git remote remove origin</code></p>
<h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><ul>
<li>将之前一部分提交合并到一起</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git rebase -i 想要合并的版本号</span><br><span class="line">从当前到你所选的版本号进行合并</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~数字 </span><br><span class="line">从当前开始找最近的三条记录合并到一起</span><br></pre></td></tr></table></figure>
<p>输入完上述之后会出现<br><img src="https://img-blog.csdnimg.cn/20210113211935327.png" alt="出现内容"><br>将下面的pick换成s<br><img src="https://img-blog.csdnimg.cn/2021011321202839.png" alt="变换"><br>PS：参数s代表将此版本与上面的版本进行合并<br>之后会出现如下内容<br><img src="https://img-blog.csdnimg.cn/20210113212222460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIWUNhcmdl,size_16,color_FFFFFF,t_70" alt="整合提交信息"><br>此操作是将三次提交信息进行整合，修改为如下样子<br><img src="https://img-blog.csdnimg.cn/20210113212317876.png" alt="修改"><br>注意：如果版本已经上传到远程仓库，则尽可能避免合并此分支</p>
<h4 id="git修改分支名称"><a href="#git修改分支名称" class="headerlink" title="git修改分支名称"></a>git修改分支名称</h4><p>假设分支名称为master,然后我们需要将其改写成为dev<br><strong>当前操作在本地进行,并未进行云端同步</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git branch -m <span class="keyword">master</span> <span class="title">dev</span></span><br></pre></td></tr></table></figure>
<p>如果已经推送到远程分支,并且本地和远程分支的名称是对应的</p>
<ol>
<li>重命名远程分支所对应的本地分支<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git branch -m <span class="keyword">master</span> <span class="title">dev</span> </span><br></pre></td></tr></table></figure></li>
<li>删除远程分支<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> --<span class="built_in">delete</span> <span class="built_in">origin</span> master </span><br></pre></td></tr></table></figure></li>
<li>上传新命名完成之后的本地分支<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> dev</span><br></pre></td></tr></table></figure></li>
<li>将修改后的本地分支与远程分支相关联<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">git branch --<span class="keyword">set</span>-upstream-<span class="keyword">to</span> origin/dev</span><br></pre></td></tr></table></figure>
借鉴来源:<a href="https://www.jianshu.com/p/cc740394faf5">git修改分支名称——简书</a></li>
</ol>
<blockquote>
<p>注意:<br>1.最后远程修改并未经过实践,也许并不可以实用,本人只使用到本地分支更改名称</p>
</blockquote>
<blockquote>
<p>其他:<strong>git brach</strong>的相关使用方法<br/><br><strong>删除:</strong><br> git push origin :branchName  # 删除远程分支<br>git push origin –delete new # 删除远程分支new<br>git branch -d branchName     # 删除本地分支，强制删除用-D<br>git branch -d test      # 删除本地test分支<br>git branch -D test      # 强制删除本地test分支<br>git remote prune origin # 远程删除了，本地还能看到远程存在，这条命令删除远程不存在的分支<br/><br><strong>查看:</strong><br>git branch      # 列出本地分支<br>git branch -r   # 列出远端分支<br>git branch -a   # 列出所有分支<br>git branch -v   # 查看各个分支最后一个提交对象的信息<br>git branch –merge      # 查看已经合并到当前分支的分支<br>git branch –no-merge   # 查看为合并到当前分支的分支<br>git remote show origin  # 可以查看remote地址，远程分支<br/><br><strong>新建:</strong><br>git branch test # 新建test分支<br>git branch newBrach 3defc69 # 指定哈希3defc69，新建分支名字为newBrach<br>git checkout -b newBrach origin/master # 取回远程主机的更新以后，在它的基础上创建一个新的分支<br>git checkout -b newBrach 3defc69 # 以哈希值3defc69，新建 newBrach 分支，并切换到该分支<br/><br><strong>连接:</strong><br>git branch –set-upstream dev origin/dev     # 将本地dev分支与远程dev分支之间建立链接<br>git branch –set-upstream master origin/next # 手动建立追踪关系  <br/><br><strong>分支切换:</strong><br>git checkout test     # 切换到test分支<br>git checkout -b test  # 新建+切换到test分支<br>git checkout -b test dev # 基于dev新建test分支，并切换   <br/><br><strong>远端:</strong><br>git fetch &lt;远程主机名&gt; &lt;分支名&gt;   # fetch取回所有分支（branch）的更新<br>git fetch origin remotebranch[:localbranch]   #  从远端拉去分支[到本地指定分支]<br>git merge origin/branch   # 合并远端上指定分支<br>git pull origin remotebranch:localbranch  #  拉去远端分支到本地分支<br>git push origin branch    # 将当前分支，推送到远端上指定分支<br>git push origin localbranch:remotebranch  # 推送本地指定分支，到远端上指定分支<br>git push origin :remotebranch   # 删除远端指定分支<br>git checkout -b [–track] test origin/dev # 基于远端dev分支，新建本地test分支[同时设置跟踪]  <br/><br><strong>以上内容粘贴自linux文档,搬运工ing</strong></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>git配置以及与gitee联动</title>
    <url>/2021/07/12/git%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E4%B8%8Egitee%E8%81%94%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>新系统配置完成之后，怎能缺少git呢</p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>首先配置git的全局信息，代码如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span></span><br><span class="line">填写你的全局用户名</span><br><span class="line">git config --global user.email <span class="string">&quot;email&quot;</span></span><br><span class="line">填写你的邮箱号（其实可以不写邮箱，只是一个标识）</span><br></pre></td></tr></table></figure>
<p>之后在终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa –C <span class="string">&quot;你的邮箱号&quot;</span></span><br></pre></td></tr></table></figure>
<p>如图所示，之后就是多次输入回车，便可获得以下内容<br><img src="https://img-blog.csdnimg.cn/2021032921000723.png" alt="生成ssh文件"><br><img src="https://img-blog.csdnimg.cn/20210329210044299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIWUNhcmdl,size_16,color_FFFFFF,t_70" alt="成功"><br>之后你的SSH公钥就存放在<code>~/.ssh/id_rsa.pub</code>中，因此我们直接输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>进行查看，之后复制到gitee的相关公钥粘贴便可<br>之后我们需要在终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T 你的gitee账户@gitee.com</span><br></pre></td></tr></table></figure>
<p>之后会显示<br><img src="https://img-blog.csdnimg.cn/20210329210821217.png" alt="你好"><br>之后显示这个代表配置完成<br><img src="https://img-blog.csdnimg.cn/20210329210912932.png" alt="完成"></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo中创建博客文章</title>
    <url>/2021/07/12/hexo%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搭建完成博客之后，当然是要写东西的</p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ol>
<li>在博客根目录下，输入<code>hexo n &quot;博客主题&quot;</code>便可以输出一篇文章</li>
<li>然后通过使用markdown等相关编写软件，来对md文件进行编写</li>
<li>输入<code>hexo g &amp; hexo d</code>来对博客进行上载(上载到github，或者<code>hexo g &amp; hexo s</code>在<code>localhost:4000</code>上进行查看<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1>这么写一篇博客，看着我都好累，因此有个比较好的插件进行推荐<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2>在博客根目录下输入<code> npm install --save hexo-admin</code>来进行安装插件<br>之后启动网站在浏览器中输入<code>localhost:4000/admin</code>进行编写，界面相对来讲简单很多</li>
</ol>
<p><img src="/images/pasted-2.png" alt="upload successful"><br>之后有许许多多的文件来进行讲解，具体贴个链接得了<br><a href="ttps://blog.csdn.net/smileyan9/article/details/86666824">链接点我</a></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx.conf的详细配置介绍(转载)</title>
    <url>/2021/07/13/nginx-conf%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文为转载文章，由于博主文章很好，故转载保存<br>作者：程序员自由之路<br>出处：<a href="https://www.cnblogs.com/54chensongxia/p/12938929.html">https://www.cnblogs.com/54chensongxia/p/12938929.html</a><br>版权：本作品采用「署名-非商业性使用-相同方式共享 4.0 国际」许可协议进行许可</p>
<span id="more"></span>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>Nginx的主配置文件是nginx.conf，这个配置文件一共由三部分组成，分别为全局块、events块和http块。在http块中，又包含http全局块、多个server块。每个server块中，可以包含server全局块和多个location块。在同一配置块中嵌套的配置块，各个之间不存在次序关系。</p>
<p>配置文件支持大量可配置的指令，绝大多数指令不是特定属于某一个块的。同一个指令放在不同层级的块中，其作用域也不同，一般情况下，高一级块中的指令可以作用于自身所在的块和此块包含的所有低层级块。如果某个指令在两个不同层级的块中同时出现，则采用“就近原则”，即以较低层级块中的配置为准。比如，某指令同时出现在http全局块中和server块中，并且配置不同，则应该以server块中的配置为准。</p>
<p>整个配置文件的结构大致如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全局块</span></span><br><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"><span class="comment">#event块</span></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#http块</span></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="comment">#http全局块</span></span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    <span class="comment">#server块</span></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="comment">#server全局块</span></span><br><span class="line">        listen       8000;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        <span class="comment">#location块</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#这边可以有多个server块</span></span><br><span class="line">    server &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定可以运行nginx服务的用户和用户组，只能在全局块配置</span></span><br><span class="line"><span class="comment"># user [user] [group]</span></span><br><span class="line"><span class="comment"># 将user指令注释掉，或者配置成nobody的话所有用户都可以运行</span></span><br><span class="line"><span class="comment"># user nobody nobody;</span></span><br><span class="line"><span class="comment"># user指令在Windows上不生效，如果你制定具体用户和用户组会报小面警告</span></span><br><span class="line"><span class="comment"># nginx: [warn] &quot;user&quot; is not supported, ignored in D:\software\nginx-1.18.0/conf/nginx.conf:2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定工作线程数，可以制定具体的进程数，也可使用自动模式，这个指令只能在全局块配置</span></span><br><span class="line"><span class="comment"># worker_processes number | auto；</span></span><br><span class="line"><span class="comment"># 列子：指定4个工作线程，这种情况下会生成一个master进程和4个worker进程</span></span><br><span class="line"><span class="comment"># worker_processes 4;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定pid文件存放的路径，这个指令只能在全局块配置</span></span><br><span class="line"><span class="comment"># pid logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定错误日志的路径和日志级别，此指令可以在全局块、http块、server块以及location块中配置。(在不同的块配置有啥区别？？)</span></span><br><span class="line"><span class="comment"># 其中debug级别的日志需要编译时使用--with-debug开启debug开关</span></span><br><span class="line"><span class="comment"># error_log [path] [debug | info | notice | warn | error | crit | alert | emerg] </span></span><br><span class="line"><span class="comment"># error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment"># error_log  logs/error.log  info;</span></span><br></pre></td></tr></table></figure>
<h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><p>events块涉及的指令主要影响Nginx服务器与用户的网络连接。常用到的设置包括是否开启对多worker process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型处理连接请求，每个worker process可以同时支持的最大连接数等。<br>这一部分的指令对Nginx服务器的性能影响较大，在实际配置中应该根据实际情况灵活调整。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当某一时刻只有一个网络连接到来时，多个睡眠进程会被同时叫醒，但只有一个进程可获得连接。如果每次唤醒的进程数目太多，会影响一部分系统性能。在Nginx服务器的多进程下，就有可能出现这样的问题。</span></span><br><span class="line"><span class="comment"># 开启的时候，将会对多个Nginx进程接收连接进行序列化，防止多个进程对连接的争抢</span></span><br><span class="line"><span class="comment"># 默认是开启状态，只能在events块中进行配置</span></span><br><span class="line"><span class="comment"># accept_mutex on | off;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接。 </span></span><br><span class="line"><span class="comment"># 如果nginx使用kqueue连接方法，那么这条指令会被忽略，因为这个方法会报告在等待被接受的新连接的数量。</span></span><br><span class="line"><span class="comment"># 默认是off状态，只能在event块配置</span></span><br><span class="line"><span class="comment"># multi_accept on | off;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定使用哪种网络IO模型，method可选择的内容有：select、poll、kqueue、epoll、rtsig、/dev/poll以及eventport，一般操作系统不是支持上面所有模型的。</span></span><br><span class="line"><span class="comment"># 只能在events块中进行配置</span></span><br><span class="line"><span class="comment"># use method</span></span><br><span class="line"><span class="comment"># use epoll</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置允许每一个worker process同时开启的最大连接数，当每个工作进程接受的连接数超过这个值时将不再接收连接</span></span><br><span class="line"><span class="comment"># 当所有的工作进程都接收满时，连接进入logback，logback满后连接被拒绝</span></span><br><span class="line"><span class="comment"># 只能在events块中进行配置</span></span><br><span class="line"><span class="comment"># 注意：这个值不能超过超过系统支持打开的最大文件数，也不能超过单个进程支持打开的最大文件数，具体可以参考这篇文章：https://cloud.tencent.com/developer/article/1114773</span></span><br><span class="line"><span class="comment"># worker_connections  1024;</span></span><br></pre></td></tr></table></figure>
<h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><p>http块是Nginx服务器配置中的重要部分，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个模块中。<br>前面已经提到，http块中可以包含自己的全局块，也可以包含server块，server块中又可以进一步包含location块，在本书中我们使用“http全局块”来表示http中自己的全局块，即http块中不包含在server块中的部分。<br>可以在http全局块中配置的指令包括文件引入、MIME-Type定义、日志自定义、是否使用sendfile传输文件、连接超时时间、单连接请求数上限等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常用的浏览器中，可以显示的内容有HTML、XML、GIF及Flash等种类繁多的文本、媒体等资源，浏览器为区分这些资源，需要使用MIME Type。换言之，MIME Type是网络资源的媒体类型。Nginx服务器作为Web服务器，必须能够识别前端请求的资源类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># include指令，用于包含其他的配置文件，可以放在配置文件的任何地方，但是要注意你包含进来的配置文件一定符合配置规范，比如说你include进来的配置是worker_processes指令的配置，而你将这个指令包含到了http块中，着肯定是不行的，上面已经介绍过worker_processes指令只能在全局块中。</span></span><br><span class="line"><span class="comment"># 下面的指令将mime.types包含进来，mime.types和ngin.cfg同级目录，不同级的话需要指定具体路径</span></span><br><span class="line"><span class="comment"># include  mime.types;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置默认类型，如果不加此指令，默认值为text/plain。</span></span><br><span class="line"><span class="comment"># 此指令还可以在http块、server块或者location块中进行配置。</span></span><br><span class="line"><span class="comment"># default_type  application/octet-stream;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># access_log配置，此指令可以在http块、server块或者location块中进行设置</span></span><br><span class="line"><span class="comment"># 在全局块中，我们介绍过errer_log指令，其用于配置Nginx进程运行时的日志存放和级别，此处所指的日志与常规的不同，它是指记录Nginx服务器提供服务过程应答前端请求的日志</span></span><br><span class="line"><span class="comment"># access_log path [format [buffer=size]]</span></span><br><span class="line"><span class="comment"># 如果你要关闭access_log,你可以使用下面的命令</span></span><br><span class="line"><span class="comment"># access_log off;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log_format指令，用于定义日志格式，此指令只能在http块中进行配置</span></span><br><span class="line"><span class="comment"># log_format  main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line"><span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line"><span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line"><span class="comment"># 定义了上面的日志格式后，可以以下面的形式使用日志</span></span><br><span class="line"><span class="comment"># access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启关闭sendfile方式传输文件，可以在http块、server块或者location块中进行配置</span></span><br><span class="line"><span class="comment"># sendfile  on | off;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置sendfile最大数据量,此指令可以在http块、server块或location块中配置</span></span><br><span class="line"><span class="comment"># sendfile_max_chunk size;</span></span><br><span class="line"><span class="comment"># 其中，size值如果大于0，Nginx进程的每个worker process每次调用sendfile()传输的数据量最大不能超过这个值(这里是128k，所以每次不能超过128k)；如果设置为0，则无限制。默认值为0。</span></span><br><span class="line"><span class="comment"># sendfile_max_chunk 128k;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置连接超时时间,此指令可以在http块、server块或location块中配置。</span></span><br><span class="line"><span class="comment"># 与用户建立会话连接后，Nginx服务器可以保持这些连接打开一段时间</span></span><br><span class="line"><span class="comment"># timeout，服务器端对连接的保持时间。默认值为75s;header_timeout，可选项，在应答报文头部的Keep-Alive域设置超时时间：“Keep-Alive:timeout= header_timeout”。报文中的这个指令可以被Mozilla或者Konqueror识别。</span></span><br><span class="line"><span class="comment"># keepalive_timeout timeout [header_timeout]</span></span><br><span class="line"><span class="comment"># 下面配置的含义是，在服务器端保持连接的时间设置为120 s，发给用户端的应答报文头部中Keep-Alive域的超时时间设置为100 s。</span></span><br><span class="line"><span class="comment"># keepalive_timeout 120s 100s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置单连接请求数上限，此指令可以在http块、server块或location块中配置。</span></span><br><span class="line"><span class="comment"># Nginx服务器端和用户端建立会话连接后，用户端通过此连接发送请求。指令keepalive_requests用于限制用户通过某一连接向Nginx服务器发送请求的次数。默认是100</span></span><br><span class="line"><span class="comment"># keepalive_requests number;</span></span><br></pre></td></tr></table></figure>
<h3 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h3><p>server块和“虚拟主机”的概念有密切联系。<br>虚拟主机，又称虚拟服务器、主机空间或是网页空间，它是一种技术。该技术是为了节省互联网服务器硬件成本而出现的。这里的“主机”或“空间”是由实体的服务器延伸而来，硬件系统可以基于服务器群，或者单个服务器等。虚拟主机技术主要应用于HTTP、FTP及EMAIL等多项服务，将一台服务器的某项或者全部服务内容逻辑划分为多个服务单位，对外表现为多个服务器，从而充分利用服务器硬件资源。从用户角度来看，一台虚拟主机和一台独立的硬件主机是完全一样的。<br>在使用Nginx服务器提供Web服务时，利用虚拟主机的技术就可以避免为每一个要运行的网站提供单独的Nginx服务器，也无需为每个网站对应运行一组Nginx进程。虚拟主机技术使得Nginx服务器可以在同一台服务器上只运行一组Nginx进程，就可以运行多个网站。<br>在前面提到过，每一个http块都可以包含多个server块，而每个server块就相当于一台虚拟主机，它内部可有多台主机联合提供服务，一起对外提供在逻辑上关系密切的一组服务（或网站）。<br>和http块相同，server块也可以包含自己的全局块，同时可以包含多个location块。在server全局块中，最常见的两个配置项是本虚拟主机的监听配置和本虚拟主机的名称或IP配置。</p>
<h3 id="listen指令"><a href="#listen指令" class="headerlink" title="listen指令"></a>listen指令</h3><p>server块中最重要的指令就是listen指令，这个指令有三种配置语法。这个指令默认的配置值是：listen *:80 | *:8000；只能在server块种配置这个指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//第一种</span><br><span class="line">listen address[:port] [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [<span class="built_in">bind</span>] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];</span><br><span class="line"></span><br><span class="line">//第二种</span><br><span class="line">listen port [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [<span class="built_in">bind</span>] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];</span><br><span class="line"></span><br><span class="line">//第三种（可以不用重点关注）</span><br><span class="line">listen unix:path [default_server] [ssl] [http2 | spdy] [proxy_protocol] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [<span class="built_in">bind</span>] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];</span><br></pre></td></tr></table></figure>
<p>listen指令的配置非常灵活，可以单独制定ip，单独指定端口或者同时指定ip和端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen 127.0.0.1:8000;  <span class="comment">#只监听来自127.0.0.1这个IP，请求8000端口的请求</span></span><br><span class="line">listen 127.0.0.1; <span class="comment">#只监听来自127.0.0.1这个IP，请求80端口的请求（不指定端口，默认80）</span></span><br><span class="line">listen 8000; <span class="comment">#监听来自所有IP，请求8000端口的请求</span></span><br><span class="line">listen *:8000; <span class="comment">#和上面效果一样</span></span><br><span class="line">listen localhost:8000; <span class="comment">#和第一种效果一致</span></span><br></pre></td></tr></table></figure>
<p>关于上面的一些重要参数做如下说明：</p>
<ul>
<li>address：监听的IP地址（请求来源的IP地址），如果是IPv6的地址，需要使用中括号“[]”括起来，比如[fe80::1]等。</li>
<li>port：端口号，如果只定义了IP地址没有定义端口号，就使用80端口。这边需要做个说明：要是你压根没配置listen指令，那么那么如果nginx以超级用户权限运行，则使用*:80，否则使用*:8000。多个虚拟主机可以同时监听同一个端口,但是server_name需要设置成不一样；</li>
<li>default_server：假如通过Host没匹配到对应的虚拟主机，则通过这台虚拟主机处理。具体的可以参考<a href="https://segmentfault.com/a/1190000015681272">这篇文章</a>，写的不错。</li>
<li>backlog=number：设置监听函数listen()最多允许多少网络连接同时处于挂起状态，在FreeBSD中默认为-1，其他平台默认为511。</li>
<li>accept_filter=filter，设置监听端口对请求的过滤，被过滤的内容不能被接收和处理。本指令只在FreeBSD和NetBSD 5.0+平台下有效。filter可以设置为dataready或httpready，感兴趣的读者可以参阅Nginx的官方文档。</li>
<li>bind：标识符，使用独立的bind()处理此address:port；一般情况下，对于端口相同而IP地址不同的多个连接，Nginx服务器将只使用一个监听命令，并使用bind()处理端口相同的所有连接。</li>
<li>ssl：标识符，设置会话连接使用SSL模式进行，此标识符和Nginx服务器提供的HTTPS服务有关。<br>listen指令的使用看起来比较复杂，但其实在一般的使用过程中，相对来说比较简单，并不会进行太复杂的配置。<h3 id="server-name指令"><a href="#server-name指令" class="headerlink" title="server_name指令"></a>server_name指令</h3>用于配置虚拟主机的名称。语法是：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Syntax:	server_name name ...;</span><br><span class="line">Default:	</span><br><span class="line">server_name <span class="string">&quot;&quot;</span>;</span><br><span class="line">Context:	server</span><br></pre></td></tr></table></figure>

<p>对于name 来说，可以只有一个名称，也可以由多个名称并列，之间用空格隔开。每个名字就是一个域名，由两段或者三段组成，之间由点号“.”隔开。比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server_name myserver.com www.myserver.com</span><br></pre></td></tr></table></figure>

<p>在该例中，此虚拟主机的名称设置为myserver.com或www. myserver.com。Nginx服务器规定，第一个名称作为此虚拟主机的主要名称。</p>
<p>在name 中可以使用通配符“*”，但通配符只能用在由三段字符串组成的名称的首段或尾段，或者由两段字符串组成的名称的尾段，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server_name myserver.* *.myserver.com</span><br></pre></td></tr></table></figure>

<p>另外name还支持正则表达式的形式。这边就不详细展开了。</p>
<p>由于server_name指令支持使用通配符和正则表达式两种配置名称的方式，因此在包含有多个虚拟主机的配置文件中，可能会出现一个名称被多个虚拟主机的server_name匹配成功。那么，来自这个名称的请求到底要交给哪个虚拟主机处理呢？Nginx服务器做出如下规定：</p>
<ol>
<li><p>对于匹配方式不同的，按照以下的优先级选择虚拟主机，排在前面的优先处理请求。<br>① 准确匹配server_name<br>② 通配符在开始时匹配server_name成功<br>③ 通配符在结尾时匹配server_name成功<br>④ 正则表达式匹配server_name成功  </p>
</li>
<li><p>在以上四种匹配方式中，如果server_name被处于同一优先级的匹配方式多次匹配成功，则首次匹配成功的虚拟主机处理请求。<br>有时候我们希望使用基于IP地址的虚拟主机配置，比如访问192.168.1.31有虚拟主机1处理，访问192.168.1.32由虚拟主机2处理。<br>这时我们要先网卡绑定别名，比如说网卡之前绑定的IP是192.168.1.30，现在将192.168.1.31和192.168.1.32这两个IP都绑定到这个网卡上，那么请求这个两个IP的请求才会到达这台机器。<br>绑定别名后进行以下配置即可：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">	   listen:  80;</span><br><span class="line">	   server_name:  192.168.1.31;</span><br><span class="line">     ...</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">	   listen:  80;</span><br><span class="line">	   server_name:  192.168.1.32;</span><br><span class="line">     ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="location块"><a href="#location块" class="headerlink" title="location块"></a>location块</h3><p>每个server块中可以包含多个location块。在整个Nginx配置文档中起着重要的作用，而且Nginx服务器在许多功能上的灵活性往往在location指令的配置中体现出来。<br>location块的主要作用是，基于Nginx服务器接收到的请求字符串（例如， server_name/uri-string），对除虚拟主机名称（也可以是IP别名，后文有详细阐述）之外的字符串（前例中“/uri-string”部分）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能都是在这部分实现。许多第三方模块的配置也是在location块中提供功能。<br>在Nginx的官方文档中定义的location的语法结构为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>其中，uri变量是待匹配的请求字符串，可以是不含正则表达的字符串，如/myserver.php等；也可以是包含有正则表达的字符串，如 .php$（表示以.php结尾的URL）等。为了下文叙述方便，我们约定，不含正则表达的uri称为“标准uri”，使用正则表达式的uri称为“正则uri”。<br>其中方括号里的部分，是可选项，用来改变请求字符串与 uri 的匹配方式。在介绍四种标识的含义之前，我们需要先了解不添加此选项时，Nginx服务器是如何在server块中搜索并使用location块的uri和请求字符串匹配的。<br>在不添加此选项时，Nginx服务器首先在server块的多个location块中搜索是否有标准uri和请求字符串匹配，如果有多个可以匹配，就记录匹配度最高的一个。然后，服务器再用location块中的正则uri和请求字符串匹配，当第一个正则uri匹配成功，结束搜索，并使用这个location块处理此请求；如果正则匹配全部失败，就使用刚才记录的匹配度最高的location块处理此请求。<br>了解了上面的内容，就可以解释可选项中各个标识的含义了：</p>
<ul>
<li><p>“=”，用于标准uri前，要求请求字符串与uri严格匹配。如果已经匹配成功，就停止继续向下搜索并立即处理此请求。</p>
</li>
<li><p>“^～”，用于标准uri前，要求Nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。</p>
</li>
<li><p>“～”，用于表示uri包含正则表达式，并且区分大小写。</p>
</li>
<li><p>“～<em>”，用于表示uri包含正则表达式，并且不区分大小写。注意如果uri包含正则表达式，就必须要使用“～”或者“～</em>”标识。</p>
<blockquote>
<p>我们知道，在浏览器传送URI时对一部分字符进行URL编码，比如空格被编码为“%20”，问号被编码为“%3f”等。“～”有一个特点是，它对uri中的这些符号将会进行编码处理。比如，如果location块收到的URI为“/html/%20/data”，则当Nginx服务器搜索到配置为“～ /html/ /data”的location时，可以匹配成功。</p>
</blockquote>
</li>
</ul>
<h3 id="root指令"><a href="#root指令" class="headerlink" title="root指令"></a>root指令</h3><p>这个指令用于设置请求寻找资源的跟目录，此指令可以在http块、server块或者location块中配置。由于使用Nginx服务器多数情况下要配置多个location块对不同的请求分别做出处理，因此该指令通常在location块中进行设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root path</span><br></pre></td></tr></table></figure>
<p>path变量中可以包含Nginx服务器预设的大多数变量，只有documentroot和realpath_root不可以使用。</p>
<h3 id="一个配置文件的列子"><a href="#一个配置文件的列子" class="headerlink" title="一个配置文件的列子"></a>一个配置文件的列子</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">######Nginx配置文件nginx.conf中文详解#####</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义Nginx运行的用户和用户组</span></span><br><span class="line">user www www;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx进程数，建议设置为等于CPU总核心数。</span></span><br><span class="line">worker_processes 8;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class="line">error_log /usr/<span class="built_in">local</span>/nginx/logs/error.log info;</span><br><span class="line"></span><br><span class="line"><span class="comment">#进程pid文件</span></span><br><span class="line">pid /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定进程可以打开的最大描述符：数目</span></span><br><span class="line"><span class="comment">#工作模式与连接数上限</span></span><br><span class="line"><span class="comment">#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span></span><br><span class="line"><span class="comment">#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。</span></span><br><span class="line"><span class="comment">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span></span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span></span><br><span class="line">    <span class="comment">#是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span></span><br><span class="line">    <span class="comment">#补充说明：</span></span><br><span class="line">    <span class="comment">#与apache相类，nginx针对不同的操作系统，有不同的事件模型</span></span><br><span class="line">    <span class="comment">#A）标准事件模型</span></span><br><span class="line">    <span class="comment">#Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span></span><br><span class="line">    <span class="comment">#B）高效事件模型</span></span><br><span class="line">    <span class="comment">#Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span></span><br><span class="line">    <span class="comment">#Epoll：使用于Linux内核2.6版本及以后的系统。</span></span><br><span class="line">    <span class="comment">#/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span></span><br><span class="line">    <span class="comment">#Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span></span><br><span class="line">    use epoll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#单个进程最大连接数（最大连接数=连接数*进程数）</span></span><br><span class="line">    <span class="comment">#根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。</span></span><br><span class="line">    worker_connections 65535;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive超时时间。</span></span><br><span class="line">    keepalive_timeout 60;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span></span><br><span class="line">    <span class="comment">#分页大小可以用命令getconf PAGESIZE 取得。</span></span><br><span class="line">    <span class="comment">#[root@web001 ~]# getconf PAGESIZE</span></span><br><span class="line">    <span class="comment">#4096</span></span><br><span class="line">    <span class="comment">#但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span></span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span></span><br><span class="line">    open_file_cache max=65535 inactive=60s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#这个是指多长时间检查一次缓存的有效信息。</span></span><br><span class="line">    <span class="comment">#语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span></span><br><span class="line">    open_file_cache_valid 80s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span></span><br><span class="line">    <span class="comment">#语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span></span><br><span class="line">    open_file_cache_min_uses 1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件时记录cache错误.</span></span><br><span class="line">    open_file_cache_errors on;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span></span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    include mime.types;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#默认文件类型</span></span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#默认编码</span></span><br><span class="line">    <span class="comment">#charset utf-8;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#服务器名字的hash表大小</span></span><br><span class="line">    <span class="comment">#保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span></span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span></span><br><span class="line">    client_header_buffer_size 32k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span></span><br><span class="line">    large_client_header_buffers 4 64k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设定通过nginx上传文件的大小</span></span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span></span><br><span class="line">    <span class="comment">#sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span></span><br><span class="line">    sendfile on;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开启目录列表访问，合适下载服务器，默认关闭。</span></span><br><span class="line">    autoindex on;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span></span><br><span class="line">    tcp_nopush on;</span><br><span class="line">     </span><br><span class="line">    tcp_nodelay on;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#长连接超时时间，单位是秒</span></span><br><span class="line">    keepalive_timeout 120;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span></span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip模块设置</span></span><br><span class="line">    gzip on; <span class="comment">#开启gzip压缩输出</span></span><br><span class="line">    gzip_min_length 1k;    <span class="comment">#最小压缩文件大小</span></span><br><span class="line">    gzip_buffers 4 16k;    <span class="comment">#压缩缓冲区</span></span><br><span class="line">    gzip_http_version 1.0;    <span class="comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span></span><br><span class="line">    gzip_comp_level 2;    <span class="comment">#压缩等级</span></span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;    <span class="comment">#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span></span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开启限制IP连接数的时候需要使用</span></span><br><span class="line">    <span class="comment">#limit_zone crawler $binary_remote_addr 10m;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#负载均衡配置</span></span><br><span class="line">    upstream jh.w3cschool.cn &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span></span><br><span class="line">        server 192.168.80.121:80 weight=3;</span><br><span class="line">        server 192.168.80.122:80 weight=2;</span><br><span class="line">        server 192.168.80.123:80 weight=3;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#nginx的upstream目前支持4种方式的分配</span></span><br><span class="line">        <span class="comment">#1、轮询（默认）</span></span><br><span class="line">        <span class="comment">#每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span></span><br><span class="line">        <span class="comment">#2、weight</span></span><br><span class="line">        <span class="comment">#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span></span><br><span class="line">        <span class="comment">#例如：</span></span><br><span class="line">        <span class="comment">#upstream bakend &#123;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.14 weight=10;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.15 weight=10;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#2、ip_hash</span></span><br><span class="line">        <span class="comment">#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span></span><br><span class="line">        <span class="comment">#例如：</span></span><br><span class="line">        <span class="comment">#upstream bakend &#123;</span></span><br><span class="line">        <span class="comment">#    ip_hash;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.14:88;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.15:80;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#3、fair（第三方）</span></span><br><span class="line">        <span class="comment">#按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span></span><br><span class="line">        <span class="comment">#upstream backend &#123;</span></span><br><span class="line">        <span class="comment">#    server server1;</span></span><br><span class="line">        <span class="comment">#    server server2;</span></span><br><span class="line">        <span class="comment">#    fair;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#4、url_hash（第三方）</span></span><br><span class="line">        <span class="comment">#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span></span><br><span class="line">        <span class="comment">#例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span></span><br><span class="line">        <span class="comment">#upstream backend &#123;</span></span><br><span class="line">        <span class="comment">#    server squid1:3128;</span></span><br><span class="line">        <span class="comment">#    server squid2:3128;</span></span><br><span class="line">        <span class="comment">#    hash $request_uri;</span></span><br><span class="line">        <span class="comment">#    hash_method crc32;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#tips:</span></span><br><span class="line">        <span class="comment">#upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span></span><br><span class="line">        <span class="comment">#    ip_hash;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:9090 down;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:8080 weight=2;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:6060;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:7070 backup;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#每个设备的状态设置为:</span></span><br><span class="line">        <span class="comment">#1.down表示单前的server暂时不参与负载</span></span><br><span class="line">        <span class="comment">#2.weight为weight越大，负载的权重就越大。</span></span><br><span class="line">        <span class="comment">#3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span></span><br><span class="line">        <span class="comment">#4.fail_timeout:max_fails次失败后，暂停的时间。</span></span><br><span class="line">        <span class="comment">#5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span></span><br><span class="line">        <span class="comment">#client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span></span><br><span class="line">        <span class="comment">#client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span></span><br><span class="line">        <span class="comment">#location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">#虚拟主机的配置</span></span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">#监听端口</span></span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#域名可以有多个，用空格隔开</span></span><br><span class="line">        server_name www.w3cschool.cn w3cschool.cn;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        root /data/www/w3cschool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#对******进行负载均衡</span></span><br><span class="line">        location ~ .*.(php|php5)?$</span><br><span class="line">        &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            include fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#图片缓存时间设置</span></span><br><span class="line">        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 10d;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#JS和CSS缓存时间设置</span></span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#日志格式设定</span></span><br><span class="line">        <span class="comment">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span></span><br><span class="line">        <span class="comment">#$remote_user：用来记录客户端用户名称；</span></span><br><span class="line">        <span class="comment">#$time_local： 用来记录访问时间与时区；</span></span><br><span class="line">        <span class="comment">#$request： 用来记录请求的url与http协议；</span></span><br><span class="line">        <span class="comment">#$status： 用来记录请求状态；成功是200，</span></span><br><span class="line">        <span class="comment">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span></span><br><span class="line">        <span class="comment">#$http_referer：用来记录从那个页面链接访问过来的；</span></span><br><span class="line">        <span class="comment">#$http_user_agent：记录客户浏览器的相关信息；</span></span><br><span class="line">        <span class="comment">#通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span></span><br><span class="line">        log_format access <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#定义本虚拟主机的访问日志</span></span><br><span class="line">        access_log  /usr/<span class="built_in">local</span>/nginx/logs/host.access.log  main;</span><br><span class="line">        access_log  /usr/<span class="built_in">local</span>/nginx/logs/host.access.404.log  log404;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#对 &quot;/&quot; 启用反向代理</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:88;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span></span><br><span class="line">            proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">#以下是一些反向代理的配置，可选。</span></span><br><span class="line">            proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#允许客户端请求的最大单文件字节数</span></span><br><span class="line">            client_max_body_size 10m;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#缓冲区代理缓冲用户端请求的最大字节数，</span></span><br><span class="line">            <span class="comment">#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span></span><br><span class="line">            <span class="comment">#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span></span><br><span class="line">            client_body_buffer_size 128k;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span></span><br><span class="line">            proxy_intercept_errors on;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#后端服务器连接的超时时间_发起握手等候响应超时时间</span></span><br><span class="line">            <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class="line">            proxy_connect_timeout 90;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#后端服务器数据回传时间(代理发送超时)</span></span><br><span class="line">            <span class="comment">#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span></span><br><span class="line">            proxy_send_timeout 90;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#连接成功后，后端服务器响应时间(代理接收超时)</span></span><br><span class="line">            <span class="comment">#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span></span><br><span class="line">            proxy_read_timeout 90;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class="line">            <span class="comment">#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span></span><br><span class="line">            proxy_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#proxy_buffers缓冲区，网页平均在32k以下的设置</span></span><br><span class="line">            <span class="comment">#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span></span><br><span class="line">            proxy_buffers 4 32k;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class="line">            proxy_busy_buffers_size 64k;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span></span><br><span class="line">            <span class="comment">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span></span><br><span class="line">            proxy_temp_file_write_size 64k;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="comment">#设定查看Nginx状态的地址</span></span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log on;</span><br><span class="line">            auth_basic <span class="string">&quot;NginxStatus&quot;</span>;</span><br><span class="line">            auth_basic_user_file confpasswd;</span><br><span class="line">            <span class="comment">#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span></span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#本地动静分离反向代理配置</span></span><br><span class="line">        <span class="comment">#所有jsp的页面均交由tomcat或resin处理</span></span><br><span class="line">        location ~ .(jsp|jspx|<span class="keyword">do</span>)?$ &#123;</span><br><span class="line">            proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#所有静态文件由nginx直接读取不经过tomcat或resin</span></span><br><span class="line">        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|</span><br><span class="line">        pdf|xls|mp3|wma)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 15d; </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">######Nginx配置文件nginx.conf中文详解#####</span></span><br></pre></td></tr></table></figure>
<p>作者：程序员自由之路</p>
<p>出处：<a href="https://www.cnblogs.com/54chensongxia/p/12938929.html">https://www.cnblogs.com/54chensongxia/p/12938929.html</a></p>
<p>版权：本作品采用「署名-非商业性使用-相同方式共享 4.0 国际」许可协议进行许可。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置界面</title>
    <url>/2021/07/13/nginx%E9%85%8D%E7%BD%AE%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于本博客使用的是hexo的配置环境，每次需要进行”三连“才可以部署，因此调试了一个服务器并且使用hexo-admin进行编写博客，本文仅介绍nginx的相关配置【注意：<strong>本文章只记录了相关调试方式，并没有搭建</strong>】</p>
<span id="more"></span>

<p>由于服务器采用的是CentOS的系统，因此仅代表该系统下进行调试成功</p>
<p>本篇博客在编写初期已经实现</p>
<ol>
<li>正常的网站访问（默认界面）</li>
<li>系统中安装拥有<code>locate</code> 、<code>vim</code>等相关基本命令</li>
</ol>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="nginx-conf文件介绍"><a href="#nginx-conf文件介绍" class="headerlink" title="nginx.conf文件介绍"></a>nginx.conf文件介绍</h2><p>由于在编写的时候发现了一篇比较好的，能够比较高级的讲解相关的配置方法，因此引用此文章</p>
<p><a href="https://www.cnblogs.com/54chensongxia/p/12938929.html">点我</a></p>
<p>此文章另会转载到本网站进行保存收录</p>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><ol>
<li>首先我们需要查找配置文件的位置所在，使用<code>locate nginx.conf</code>进行查找相关位置，使用vim打开conf文件进行设置</li>
<li>之后我们需要更改网站的根目录，让其满足我们的需求。找到</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">listen 127.0.0.1:80; </span><br><span class="line">server_name  你的域名信息;</span><br><span class="line">root /你的网站根目录; </span><br><span class="line">index index.php index.html index.htm;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>修改 root的值，将你的网站根目录输入到此处</p>
<blockquote>
<p>网站根目录查询可以在有index.html的界面处，输入<code>pwd</code>来进行查询</p>
</blockquote>
<ol start="3">
<li>之后保存退出，重启nginx服务器即可</li>
</ol>
<blockquote>
<p>重启服务器指令：<code>cd /usr/sbin</code>–&gt;<code>./nginx</code>进行重启</p>
</blockquote>
<h1 id="相关错误"><a href="#相关错误" class="headerlink" title="相关错误"></a>相关错误</h1><h2 id="发现寻找不到nginx-pid"><a href="#发现寻找不到nginx-pid" class="headerlink" title="发现寻找不到nginx.pid"></a>发现寻找不到<code>nginx.pid</code></h2><p>这个就离谱，之前明明好好的，但是不知道为什么不可以了，这里有两个方法，网上大多类似（第二种好像我没有实现出来，因此采用第一种比较好）</p>
<h3 id="它没有，就给它创"><a href="#它没有，就给它创" class="headerlink" title="它没有，就给它创"></a>它没有，就给它创</h3><p>创建目录 <code>/var/run/nginx/ </code></p>
<p>就直接<code>cd /var/run</code>然后<code>ls</code>当前目录，发现莫得nginx这个文件夹,因此<code>mkdir nginx</code>，之后执行<code>nginx -s reload</code>，发现还不得，采用</p>
<p><code>cd /usr/sbin</code>–&gt;<code>./nginx</code>进行重启，之后就好了，神奇的事情2333</p>
<h3 id="修改-nginx-conf-文件，指定-pid文件-所在目录"><a href="#修改-nginx-conf-文件，指定-pid文件-所在目录" class="headerlink" title="修改 nginx.conf 文件，指定 pid文件 所在目录"></a>修改 <strong>nginx.conf</strong> 文件，指定 <strong>pid文件</strong> 所在目录</h3><ol>
<li>进入到配置文件中，解开pid前面的相关参数</li>
<li>并修改成为<code>pid   /usr/local/nginx/logs/nginx.pid;</code></li>
<li>在 <code>/usr/local/nginx</code> 目录下创建 <strong>logs 目录</strong>：<code>mkdir /usr/local/nginx/logs</code></li>
<li>之后执行上步骤的重启便可以进行解决</li>
</ol>
<h2 id="发现访问的时候是403错误"><a href="#发现访问的时候是403错误" class="headerlink" title="发现访问的时候是403错误"></a>发现访问的时候是403错误</h2><p>403代表着访问错误，说明可能没有相关权限去进行访问，因此我们首先需要启动nginx，之后在命令行中输入<code>ps -ef | grep nginx</code>来查询相关nginx的服务项</p>
<p>发现我的用户名全是root，因此在nginx的配置文件的第一项将user的内容输入为root，否则即使配置了下面的相关权限，也会未必有用</p>
<p>之后输入<code>chmod 755 文件夹路径</code>来修改文件的配置权限</p>
<p>之后重启服务器，应该就得了</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>此文章用于测试网站密码部分</title>
    <url>/2021/07/12/text/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="好像密码不正确呢？再试试吧" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="df8a7ecbcfee6a876aa005c6ebec1a24b3f566b4c4aba7896d6c09c3dfd7d53a">eff6bc219c9a3e7736cd57fbf28560be70bb9d06acf022ce4e3a4464ebba349fd95104df560b4adcc272051c471f80f1a1d90fefa9f713e3d96096abfd1ea1939851202ec9610f3413dc37cc666cf7a7c036cb1c99bd9e80030c3880558450cf92fb70724057e7ff64207d7499f12b8f118e80c7c9718f816100dba9cc7135e287e69cfedbcf776e56531e1be63a8c0a6b6b67c091f5f380f096c74e768c4f218ba1e0d758e8f0781fbfb05b87b7d2fdd6ffadf3fafc22d6f85287c41b86d77dd972c0fbc375df6fff79e1a22c5f810bf93f32220ad05a1528dbf39aebf056742c9f4bc60b6842f5b12ad835998aaad62a5c93b2174894ba438128fc5da4fac024ee6f0729eb2308605d5a9839416a1f12f5c6efc42bfc66ed1a5b7702a61f27</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">输入正确密码查看正确文章</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>有密码</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu换源</title>
    <url>/2021/07/12/ubuntu%E6%8D%A2%E6%BA%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一个很简单的博客</p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><p>由于每个版本对应着不同的源，因此需要在换源之前查询自己的系统版本（盲目换源会出现依赖问题）<br>命令：<code> lsb_release -a</code><br>截图如下：<br><img src="https://img-blog.csdnimg.cn/20210621095659761.png" alt="enenen "></p>
<p>之后根据自己查询到的版本以及codename进行查找所需要的源</p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>为了防止操作出错，因此我们需要先备份一下之前的源<br><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.back</code></p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>删除<code>/etc/apt</code>中的source.list文件中的全部内容，然后将之前找到的源地址复制到此处</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>使用</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt update</span></span><br><span class="line"><span class="attribute">apt upgrade</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>一点感想</title>
    <url>/2021/07/12/%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<p>本博客搭建于2021-7-12日，耗时一天完成，作为一个小型博客，主要作用于个人的博客撰写以及记录一些事情吧，弃用csdn ing</p>
]]></content>
      <tags>
        <tag>about</tag>
      </tags>
  </entry>
  <entry>
    <title>使用excel的函数来对数据进行匹配</title>
    <url>/2021/07/12/%E4%BD%BF%E7%94%A8excel%E7%9A%84%E5%87%BD%E6%95%B0%E6%9D%A5%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用excel中我们会遇到许许多多的问题，下面介绍如何通过公式来匹配相关数据，简化工作流程</p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><img src="https://img-blog.csdnimg.cn/20210630211352686.png" alt="123"><br>左侧为元数据，右侧为待匹配数据<br>1.<br>在待匹配数据中输入<code>=vl</code>，选择vloop函数<br><img src="https://img-blog.csdnimg.cn/20210630211456979.png" alt="122"></p>
<p>2.在函数中首先选中需要匹配的数据，及后面的姓名行（一个就可）<br><img src="https://img-blog.csdnimg.cn/20210630211533976.png" alt="12"><br>3.之后选择要进行匹配的序列，记得要绝对引用，使用$来进行固定引用单元格<br><img src="https://img-blog.csdnimg.cn/20210630211647883.png" alt="122"><br>4.之后输入2，因为要获取的内容是成绩类，在所需筛选的区域的第二列<br><img src="https://img-blog.csdnimg.cn/20210630211733441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIWUNhcmdl,size_16,color_FFFFFF,t_70" alt="23"><br>5.之后输入<code>)</code>就好，最后一项可以不用管<br><img src="https://img-blog.csdnimg.cn/20210630211906559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIWUNhcmdl,size_16,color_FFFFFF,t_70" alt="2223"></p>
<p>PS：如果需要管，会提示输入TRUE或者FALSE，根据情况选择就好<br><img src="https://img-blog.csdnimg.cn/20210630211834382.png" alt="234"><br>6.之后下拉单元格便可以完成匹配，如果没有匹配到就证明是未成功</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用esp8266</title>
    <url>/2021/07/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8esp8266/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>安装完成之后，就开始编写程序了，如51点亮第一个流水灯为例，本次尝试使用esp8266的相关模块，让其创建一个局域网</p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>以太极创客的实例代码为例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU接入点模式</span></span><br><span class="line"><span class="comment">By 太极创客（http://www.taichi-maker.com）</span></span><br><span class="line"><span class="comment">2019-03-11</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">此程序用于演示如何将NodeMCU以接入点模式工作。通过此程序，您可以使用</span></span><br><span class="line"><span class="comment">电脑或者手机连接NodeMCU所建立WiFi网络。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">网络名: taichi-maker</span></span><br><span class="line"><span class="comment">密码：12345678</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">如需获得更多关于如何使用NodeMCU开发物联网的教程和资料信息</span></span><br><span class="line"><span class="comment">请参考太极创客网站（http://www.taichi-maker.com）</span></span><br><span class="line"><span class="comment">并在首页搜索栏中搜索关键字：物联网</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ssid = <span class="string">&quot;taichi-maker&quot;</span>; <span class="comment">// 这里定义将要建立的WiFi名称。此处以&quot;taichi-maker&quot;为示例</span></span><br><span class="line">                                   <span class="comment">// 您可以将自己想要建立的WiFi名称填写入此处的双引号中</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *password = <span class="string">&quot;12345678&quot;</span>;  <span class="comment">// 这里定义将要建立的WiFi密码。此处以12345678为示例</span></span><br><span class="line">                                    <span class="comment">// 您可以将自己想要使用的WiFi密码放入引号内</span></span><br><span class="line">                                    <span class="comment">// 如果建立的WiFi不要密码，则在双引号内不要填入任何信息</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);              <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  WiFi.softAP(ssid, password);     <span class="comment">// 此语句是重点。WiFi.softAP用于启动NodeMCU的AP模式。</span></span><br><span class="line">                                   <span class="comment">// 括号中有两个参数，ssid是WiFi名。password是WiFi密码。</span></span><br><span class="line">                                   <span class="comment">// 这两个参数具体内容在setup函数之前的位置进行定义。</span></span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  Serial.print(<span class="string">&quot;Access Point: &quot;</span>);    <span class="comment">// 通过串口监视器输出信息</span></span><br><span class="line">  Serial.println(ssid);              <span class="comment">// 告知用户NodeMCU所建立的WiFi名</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address: &quot;</span>);      <span class="comment">// 以及NodeMCU的IP地址</span></span><br><span class="line">  Serial.println(WiFi.softAPIP());   <span class="comment">// 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安装相关库"><a href="#安装相关库" class="headerlink" title="安装相关库"></a>安装相关库</h2><p>进行编译的话我们需要安装支持相关编程的库文件：点击<kbd>工具</kbd>—&gt;<kbd>管理库</kbd>—&gt;搜索<code>esp8266wifi</code>—&gt;点击安装便可以</p>
<p><img src="/images/pasted-18.png" alt="upload successful"></p>
<p><img src="/images/pasted-19.png" alt="upload successful"></p>
<p><img src="/images/pasted-21.png" alt="upload successful"></p>
<p>之后我们需要选择芯片的指定型号，由于我使用的是<code>ESP-12F</code>的芯片，因此选择</p>
<p><img src="/images/pasted-24.png" alt="upload successful"></p>
<h2 id="将esp8266接入你的电脑"><a href="#将esp8266接入你的电脑" class="headerlink" title="将esp8266接入你的电脑"></a>将esp8266接入你的电脑</h2><p>与51芯片不同，接入芯片只需要一根能传输数据的<code>miro-usb</code>便可以进行实现，因此只需要找一个线将它与你电脑相连便可以了</p>
<h2 id="选择正确的端口号"><a href="#选择正确的端口号" class="headerlink" title="选择正确的端口号"></a>选择正确的端口号</h2><p>由于硬件需要选择端口来对硬件进行烧录，查找端口号的操作步骤为:右键<kbd>此电脑</kbd>—&gt;<kbd>管理</kbd>—&gt;<kbd>设备管理器</kbd>—&gt;<kbd>端口(COM和LPT)</kbd>，查找有无CH340接口，并确定它所对应的端口号</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>当代码一切正常的时候，你会在控制台得到一串信息，同时，再wifi处可以发现一个热点</p>
<p><img src="/images/pasted-25.png" alt="upload successful"></p>
<p><img src="/images/pasted-26.png" alt="upload successful"></p>
<p><img src="/images/pasted-27.png" alt="upload successful"></p>
<h1 id="产生错误"><a href="#产生错误" class="headerlink" title="产生错误"></a>产生错误</h1><h2 id="显示找不到库"><a href="#显示找不到库" class="headerlink" title="显示找不到库"></a>显示找不到库</h2><p><img src="/images/pasted-17.png" alt="upload successful"></p>
<p>尝试顺便安装下面的这两个库文件</p>
<p><img src="/images/pasted-22.png" alt="upload successful"></p>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
<p>如果还出现了错误，不妨检查一下，有没有选择正确的开发板。。。</p>
<h2 id="发现什么都没有输出"><a href="#发现什么都没有输出" class="headerlink" title="发现什么都没有输出"></a>发现什么都没有输出</h2><p>有可能是版本问题，其次上文代码只会再连接成功的时候输出一遍，因此有些高版本可能不允许一边打开串口监视器一边上传代码，因此导致代码运行时并未启动监控<br><strong>建议：<code>按esp8266的Rst键</code></strong></p>
<h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>硬件的开发总是与软件有着些许不同，也许你的程序再今天可以跑起来，但是不代表明天甚至下一刻可以使用，也许，这就是硬件的奥秘吧</p>
]]></content>
      <categories>
        <category>study</category>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>esp8266</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用php进行上传文件</title>
    <url>/2021/07/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8php%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于需要设置提交报告，因此需要写一个提交模板</p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="设置php-ini以及相关参数讲解"><a href="#设置php-ini以及相关参数讲解" class="headerlink" title="设置php.ini以及相关参数讲解"></a>设置php.ini以及相关参数讲解</h2><p>与网上大部分内容一样，需要对php.ini的内容进行修改<br>我们可以通过使用<code>locate php.ini</code>对此文件进行查找定位（如果没有请安装locate服务）<br>内容修改如下：</p>
<ul>
<li> file_uploads= On<br>（开启php文件上传功能）</li>
<li>upload_tmp_dir =<br>（开启临时存放位置，若此项为空，则为系统默认位置）</li>
<li>upload_max_filesize = 2M<br>（设置最大上传文件大小,默认为2M）<blockquote>
<p>请注意：该选项与下面的选项息息相关，如果下面没有修改，修改上面也没有用</p>
</blockquote>
</li>
<li>post_max_size = 8M<br>（设置post表单最大提交大小，<strong>要和上面的一起设置</strong> 此大小要大于上面的大小，否则容易上传空文件上来)</li>
<li>post_max_size = 100M<br>（如果启用了内存限制，则应该小于这个值【俺没用过】）</li>
<li>max_execution_time=30<br>（每个php脚本最大的运行时间，默认为30s）</li>
<li>max_input_time = 60<br>（设置php解析文件所需要的时间，若上传文件为大文件的时候，应将此项内容修改长一点，如果设置为0，则代表无限制）</li>
<li>memory_limit = 128M<br>（设置每个php脚本使用内存的最大容量，如果脚本过于垃圾，则可以限制它，防止影响其他程序，若设置为-1则代表无限制）<h2 id="上传文件参数解释"><a href="#上传文件参数解释" class="headerlink" title="上传文件参数解释"></a>上传文件参数解释</h2>当使用php上传文件时，<code>$_FILES[‘filename’]</code>则是php返回的关于上传文件的一串参数值，以下是具体解释</li>
<li><code>[‘name’]</code>    代表的是上传文件的文件名称</li>
<li><code>[‘type’] </code>文件类型，即doc文件、jpg文件，ppt文件等</li>
<li><code> [‘tmp_name’]</code>如果相关参数没有问题，文件则会被上传到临时存放位置，如上面设置的文件存放点或者是系统默认的存放位置，并在此处会返回文件的存放路径以及临时存放名称  </li>
<li><code>[‘error’] </code>如果相关参数设置没有问题，则不会产生报错，即error=0</li>
<li><code> [‘size’]</code>文件大小，代表着这个文件有多大</li>
</ul>
<h1 id="相关错误解释"><a href="#相关错误解释" class="headerlink" title="相关错误解释"></a>相关错误解释</h1><h2 id="如果发现临时文件没有内容但是一切正常不报错"><a href="#如果发现临时文件没有内容但是一切正常不报错" class="headerlink" title="如果发现临时文件没有内容但是一切正常不报错"></a>如果发现临时文件没有内容但是一切正常不报错</h2><p>这个问题是最苟的，因为不报错，所以有很多情况，其中我只讨论与我遇到的（写博客原因）</p>
<ul>
<li>请检查是否给予权限<br>网页以及php的权限基本上都是www-data，但是你的文件夹是root的，因此可能会出现无权操作文件的情况出现，因此我们可以在你设置的临时文件夹以及文件最后的存储位置，使用<br><code>sudo -u www-data touch 123</code>命令来查询是否具有权限创建文件，若发现没有，则需要使用<code>chown www-data:www-data -R &#39;你所要赋予权限的文件夹&#39;</code>进行赋予相关权限（如果显示权限不够加sudo或者使用root用户进行操作）<h2 id="如果发现临时文件存放位置为空"><a href="#如果发现临时文件存放位置为空" class="headerlink" title="如果发现临时文件存放位置为空"></a>如果发现临时文件存放位置为空</h2>一般来讲那就证明文件无法存放在相关位置，请检查文件大小是否超出php.ini中的设置，如果确实超过了，则需要对其进行更改</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个自己的个人博客(以此平台为例)</title>
    <url>/2021/07/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%BB%A5%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%BA%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>纪念一下这个博客的产生以及相关搭建问题的记录，其次<br><strong>正经人谁用csdn写博客呢？</strong></p>
<span id="more"></span>
<h1 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h1><h2 id="搭建准备"><a href="#搭建准备" class="headerlink" title="搭建准备"></a>搭建准备</h2><p>前期，我们需要准备并确保以下内容：</p>
<ul>
<li>git<br>作为一个版本控制软件，我们需要它对我们的博客进行管理，其次，由于本博客运行在github上，我们也需要将博客上载到github上，所以在某些方面而言，git也是很重要的，因此，我们可以使用命令<br><code> sudo pacman -S git</code><br>（arch的包管理器，如果是别的系统，可以去寻找对应系统的包管理器进行安装）进行安装，安装完成之后，使用<code>git -v</code>检查git版本</li>
<li>node.js<br>与git的安装方式一样，在终端输入<code>sudo pacman -S npm</code>进行安装，由于安装npm包管理器时，会自动安装node这个软件，因此运行一次就好（仅在arch中实验过，其他系统不确定），安装完成之后，输入<code>node -v</code>与<code>npm -v</code>来查看版本。  </li>
</ul>
<p><strong>需注意：</strong>node.js版本必须要求在 10.13及以上，如版本过于低，则有些java语句将无法使用，导致后续编译出错</p>
<ul>
<li>有一个github账户(可选)<br>如果你拥有一个github账户，那么你可以在后续部署中，将此博客托管到github上进行管理，让更多的人可以看见<h2 id="hexo的初始化"><a href="#hexo的初始化" class="headerlink" title="hexo的初始化"></a>hexo的初始化</h2></li>
</ul>
<p>1.由于hexo使用的是npm包管理器进行安装，因此我们可以输入<code>npm install -g hexo-cli</code>来安装hexo，其中npm的<code>-g</code>参数，代表着此软件全局安装，如果你对相关管理足够了解，你也可以采用<code>npm install hexo</code>来进行局部hexo的安装<br>2.等待安装完成之后，我们输入<code>hexo -v</code> 来查看是否报错以及相关软件是否安装成功<br>3.之后我们进入到想要创建博客的目录下，输入<code>hexo init myblogs</code>来对博客根目录进行初始化操作<br>4.然后<code>cd myblogs</code> 之后输入<code>npm install </code>进行相关包的补充（这里仍待研究<br>之后我们便将一个小型博客搭建完成，输入<code>hexo g &amp; hexo s</code>等待片刻之后在浏览器中输入<code>localhost:4000</code>便可以查看一下初始博客了～</p>
<h1 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h1><ul>
<li><code>hexo clean</code>或<code>hexo c</code> 与清除浏览器记录一样  </li>
<li><code>hexo g</code> 重新渲染静态网页  </li>
<li><code>hexo d</code> 将代码上载到相关代码托管平台</li>
<li><code>hexo s</code> 启动本地的hexo网站模块<h1 id="与github的梦幻联动"><a href="#与github的梦幻联动" class="headerlink" title="与github的梦幻联动"></a>与github的梦幻联动</h1>由于hexo是静态页面加载，符合github page的相关规定，因此我们可以将网站上载到github上。  </li>
</ul>
<p>1.我们需要有一个github的相关帐号以及绑定ssh密钥，相关操作已经在其他博客写有，本篇不再讨论<br>2.在github上创建一个仓库，名称填写为<code>你的用户名.github.io</code><br>例如：  </p>
<p><img src="/images/pasted-0.png" alt="upload successful"><br>3.修改在网站根目录下的<code>_config.yml</code>文件，找到<code>deploy</code>部分，更改为：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: 此处填写git仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>4.之后安装<code>npm install hexo-deployer-git --save</code> 来实现hexo同步github等相关平台<br>5.之后运行<code>hexo clean &amp; hexo generate &amp; hexo deploy</code> 等代码运行完成之后，就会发现在仓库中多了一些东西<br>6.找到在github上的仓库位置，点击<kbd>settings</kbd>–&gt;<kbd>Pages</kbd>然后修改配置如下：</p>
<p><img src="/images/pasted-1.png" alt="upload successful"><br>由于我写入的是main，因此在branch中选择的是main，按正常情况而言默认都是master<br>至此，等待片刻，刷新该界面，当出现上图绿色的时候，便可以点击链接访问你的网站</p>
<h1 id="出现错误汇总"><a href="#出现错误汇总" class="headerlink" title="出现错误汇总"></a>出现错误汇总</h1><h2 id="文件下载有问题，出现错误"><a href="#文件下载有问题，出现错误" class="headerlink" title="文件下载有问题，出现错误"></a>文件下载有问题，出现错误</h2><p>由于国内网络原因，下载国外的东西可能会出现错误，因此需要短暂换源，参考如下：<br>输入：<br><code>npm config set registry https://registry.npm.taobao.org</code><br>  <code>npm info underscore</code><br>  之后可以使用，但由于博客服务器在海外，因此没有实验过此代码</p>
<h2 id="搭建完成之后输入localhost-4000报错"><a href="#搭建完成之后输入localhost-4000报错" class="headerlink" title="搭建完成之后输入localhost:4000报错"></a>搭建完成之后输入<code>localhost:4000</code>报错</h2><p>很有可能是你的端口号被占用了，因此需要更改你的相关端口，不过我没遇到过，随便找了一个解决方案：  </p>
<blockquote>
<p>可以修改在网站根目录下的<code>_config.yml</code>文件的运行端口号，如需更改成4001，代码如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 4001</span><br><span class="line">  compress: <span class="literal">true</span></span><br><span class="line">  header: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="为什么使用hexo？"><a href="#为什么使用hexo？" class="headerlink" title="为什么使用hexo？"></a>为什么使用hexo？</h1><p>因为hexo相对于其他平台而言，比较老，并且教程相关完善，虽然需要对代码以及相关程序基础有一定了解，但是其环境在所有静态网站来讲已经相当不错，毕竟不想挂服务器花钱。  极客风还是阔以的，但是对于此类平台来讲，还是仍有些许缺点，比如无法及时有效的编写博客，修改较为困难，等</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>尝试使用github替我一次三连</title>
    <url>/2021/07/13/%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8github%E6%9B%BF%E6%88%91%E4%B8%80%E6%AC%A1%E4%B8%89%E8%BF%9E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于这个平台太恶心了，要是搭建到github上，得在下面一次三连才可以传输到网站上，不符合我的懒人观，并且网上有很多教程说咋咋实现，后面虽然配了一天多，然后发现了一个小问题，后面修改了之后便可以使用了</p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="另建立一个私有仓库"><a href="#另建立一个私有仓库" class="headerlink" title="另建立一个私有仓库"></a>另建立一个私有仓库</h2><p>由于方法是通过使用github action 来帮助进行管理的，因此我们要将自己的源码放置到github的私有仓库上进行管理<br>因此在博客根目录下创建一个git仓库，并将所有代码上传到github的私人仓库中进行保存<br><strong>请注意:要将主题中的git配置文件全部删除，并且如果之前有构建过上传过代码的，要将其中的所有关于git文件全部删除，否则会上传失败例如：’.git .develp_git’等</strong></p>
<h2 id="保存我们的公私钥"><a href="#保存我们的公私钥" class="headerlink" title="保存我们的公私钥"></a>保存我们的公私钥</h2><p>我们可以通过访问<code>~/.ssh</code>这个文件夹进行获取到我们的公私钥。其中公钥放置到自身的ssh钥匙中，私钥放置到私有仓库的密码中，并进行命名（请注意你的命名，会影响到后续的文件流的生成）<br><strong>请注意：私钥有相关文件描述，一定要将东西全部复制完毕，否则会产生报错</strong></p>
<h2 id="创建github-action的相关文件流"><a href="#创建github-action的相关文件流" class="headerlink" title="创建github action的相关文件流"></a>创建github action的相关文件流</h2><p>进入到私有仓库中，点击action，之后创建一个文件流，输入以下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name: Deploy Blog</span><br><span class="line"></span><br><span class="line">on: [push] <span class="comment"># 当有新push时运行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  build: <span class="comment"># 一项叫做build的任务</span></span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest <span class="comment"># 在最新版的Ubuntu系统下运行</span></span><br><span class="line">    </span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout <span class="comment"># 将仓库内master分支的内容下载到工作目录</span></span><br><span class="line">      uses: actions/checkout@v1 <span class="comment"># 脚本来自 https://github.com/actions/checkout</span></span><br><span class="line">      </span><br><span class="line">    - name: Use Node.js 16.x <span class="comment"># 配置Node环境</span></span><br><span class="line">      uses: actions/setup-node@v1 <span class="comment"># 配置脚本来自 https://github.com/actions/setup-node</span></span><br><span class="line">      with:</span><br><span class="line">        node-version: <span class="string">&quot;16.x&quot;</span></span><br><span class="line">    </span><br><span class="line">    - name: Setup Hexo env</span><br><span class="line">      env:</span><br><span class="line">        ACTION_DEPLOY_KEY: <span class="variable">$&#123;&#123; secrets.ACTION_DEPLOY_KEY &#125;</span>&#125;</span><br><span class="line">      run: |</span><br><span class="line">        <span class="comment"># set up private key for deploy</span></span><br><span class="line">        mkdir -p ~/.ssh/</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ACTION_DEPLOY_KEY</span>&quot;</span> | tr -d <span class="string">&#x27;\r&#x27;</span> &gt; ~/.ssh/id_rsa <span class="comment"># 配置秘钥</span></span><br><span class="line">        chmod 600 ~/.ssh/id_rsa</span><br><span class="line">        ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="line">        <span class="comment"># set git infomation</span></span><br><span class="line">        git config --global user.name <span class="string">&#x27;你的名字&#x27;</span> <span class="comment"># 换成你自己的邮箱和名字</span></span><br><span class="line">        git config --global user.email <span class="string">&#x27;你的邮箱&#x27;</span></span><br><span class="line">        <span class="comment"># install dependencies</span></span><br><span class="line">        npm i -g hexo-cli <span class="comment"># 安装hexo</span></span><br><span class="line">        npm i</span><br><span class="line">  </span><br><span class="line">    - name: Deploy</span><br><span class="line">      run: |</span><br><span class="line">        <span class="comment"># publish</span></span><br><span class="line">        hexo generate &amp;&amp; hexo deploy <span class="comment"># 执行部署程序</span></span><br></pre></td></tr></table></figure>
<p>以上代码参考别人得出，相关源文件已无从得出，如有侵权请联系我  </p>
<blockquote>
<p>Node环境要以大环境为主，比如这个之前的代码是10一下的，但是Hexo显然不支持10了，因此对此需要修改到16</p>
</blockquote>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>让我们在源文件的<code>source/_posts/</code>里面创建一个md文件，之后输入需要用到的相关内容（具体可以参考里面其他的md文件<br>之后将文件提交，看看action是否有变化，后面发现有变化，因此配置成功，等一下刷新一下网站便可以  </p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>后面我看很多博主都有在线修改文章的功能，当时很懵，看了很多人的博客介绍，但是并没有找到自己所找到的东西，后面翻<a href="https://theme-next.js.org/docs/theme-settings/posts">next的配置文档</a>发现其实在next的主题文件中已经包含了关于在线修改文件的配置，经过修改配置文件的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">post_edit:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>之后将自己的url填写在里面，便可以实现此功能<br>如有其他问题，请留言联系我</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>github action</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之重定位</title>
    <url>/2021/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="本文为转载"><a href="#本文为转载" class="headerlink" title="本文为转载"></a>本文为转载</h1><p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/sunjinbat/article/details/80571241">https://blog.csdn.net/sunjinbat/article/details/80571241</a><br>————————————————<br>版权声明：本文为CSDN博主「codedrinker」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sunjinbat/article/details/80571241">https://blog.csdn.net/sunjinbat/article/details/80571241</a></p>
<span id="more"></span>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>区别这两个概念之前，要知道 重定位 的概念。</p>
<p>重定位，通常来说把在装入时对目标程序中指令和数据地址修改的过程称为重定位。</p>
<p>而静态重定位就是，在逻辑地址转换为物理地址的过程中，地址变换是在进程装入时一次完成的，以后不再改变。</p>
<p>优点：是无需增加硬件地址转换机构，便于实现程序的静态连接。在早期计算机系统中大多采用这种方案。 </p>
<p>缺点：内存空间不能移动；各个用户进程很难共享内存中同一程序的副本</p>
<p>动态重定位：动态运行的装入程序把转入模块装入内存之后，并不立即把装入模块的逻辑地址进行转换，而是把这</p>
<p>种地址转换推迟到程序执行时才进行，装入内存后的所有地址都仍是逻辑地址。这种方式需要寄存器的支持，其中</p>
<p>放有当前正在执行的程序在内存空间中的起始地址。</p>
<p>优点：内存空间可以移动；各个用户进程可以共享内存中同一程序的副本。</p>
<p>缺点：增加了机器成本，而且实现存储管理的软件算法比较复杂。<br>————————————————<br>版权声明：本文为CSDN博主「codedrinker」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sunjinbat/article/details/80571241">https://blog.csdn.net/sunjinbat/article/details/80571241</a></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub配置其他域名</title>
    <url>/2021/09/10/GitHub%E9%85%8D%E7%BD%AE%E5%85%B6%E4%BB%96%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于自己有多余的域名，其次感觉github的域名不太好，因此了解一下如何将自己的域名绑定到GitHub pages上</p>
<span id="more"></span>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_34392457/article/details/89115236">GitHub Page绑定自己的域名</a></p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>首先为了绑定域名，我们首先需要有一个github的pages的界面，而这个界面往往需要创建的时候是以<code>用户名.github.io</code>进行创建的，创建之后进入到仓库的设置中，将pages服务进行打开</p>
<p><img src="https://user-images.githubusercontent.com/40520292/132868839-389ee468-6421-46fd-9e21-a9c882da933b.png" alt="image"></p>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>我们需要去域名服务商额外分配一个二级域名，这里以阿里云为例：</p>
<p>创建一个CNAME的域名解析，记录值即为<code>用户名.github.io</code></p>
<p>然后回到github的pages服务中，找到<code>Custom domain</code>选项，将其中输入框输入你刚刚创建的二级域名，然后稍等片刻，便发现解析成功</p>
<h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>受限于域名服务商的服务质量，可能你的域名需要十分钟左右的时间来进行解析，因此请保证每一次修改尝试的时候中间隔开了足够的时间，放置由于DNS的问题导致设置出现问题</p>
<p>如果多次刷新发现还是不行，建议换一个浏览器重新加载，因为浏览器的缓存数据可能对域名进行过保存，但是并未清除掉<br>请注意：如果使用的是GitHub的一键三连，那么需要更新 <code>_config.yml</code> 的相关文件，要不会访问不了<br>本人暂未配置成功，具体原因仍在探索</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib模块的使用</title>
    <url>/2021/07/27/Matplotlib%E6%A8%A1%E5%9D%97%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试根据b站大佬来扩充自己的知识面</p>
<p>使用Matplotlib模块来实现图像的绘制（基础）</p>
<span id="more"></span>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1QJ411W7SS?p=17">B站视频</a></p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">y = np.array([<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;blue&#x27;</span>)  <span class="comment"># 绘制折线图 [参数1： x轴坐标 参数2： y轴坐标 参数3：颜色]</span></span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;b&#x27;</span>, lw=<span class="number">5</span>)  <span class="comment"># [参数4： 线条宽度]</span></span><br><span class="line"><span class="comment"># 绘图分为折线、 饼状、柱状图</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">y = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">plt.bar(x, y, <span class="number">0.5</span>, alpha=<span class="number">1</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制柱状图[参数1： x轴坐标 参数2：y轴坐标 参数3： 柱状图宽度比例 参数4： 透明度 参数5： 颜色]</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>代码运行结果如下：</p>
<p><img src="/home/zhycarge/.config/Typora/typora-user-images/image-20210727163647412.png" alt="image-20210727163647412"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="在pycharm中没有看到所显示的图"><a href="#在pycharm中没有看到所显示的图" class="headerlink" title="在pycharm中没有看到所显示的图"></a>在pycharm中没有看到所显示的图</h2><p>在新版pycharm中，图像显示政策进行了修改，在新版界面下，图片显示将出现在<code>Sciview</code>里面，但是我们也可以将其调整出来，调整方法如下：</p>
<p><kbd> File</kbd>—&gt;<kbd>Settings</kbd>—&gt;<kbd>Tools</kbd>—&gt;<kbd> Python Scientific</kbd></p>
<p>之后将<code>Show plots in toolwindow</code>勾选的选项关闭即可</p>
<h2 id="发现没有图像显示"><a href="#发现没有图像显示" class="headerlink" title="发现没有图像显示"></a>发现没有图像显示</h2><p>根据b站视频所敲，但是并没有图像显示，查了一下发现在<code>jupyter</code>中，不使用show方法便可以进行显示，但是在pycharm中，需要使用show方法进行显示</p>
]]></content>
      <categories>
        <category>study</category>
        <category>视觉</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>atplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Numpy模块操作矩阵</title>
    <url>/2021/07/27/Numpy%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试根据b站大佬来扩充自己的知识面</p>
<p>使用Numpy模块来实现对矩阵的基本运算以及矩阵元素的基本查找</p>
<span id="more"></span>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1QJ411W7SS?p=17">B站视频</a></p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">data2 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(data1)    <span class="comment"># 打印矩阵内容</span></span><br><span class="line"><span class="built_in">print</span>(data2)    <span class="comment"># 打印矩阵内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data1.shape, data2.shape)  <span class="comment"># 打印矩阵维度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.zeros([<span class="number">2</span>, <span class="number">3</span>]))     <span class="comment"># 打印一个两行三列的空矩阵</span></span><br><span class="line"><span class="built_in">print</span>(np.ones([<span class="number">2</span>, <span class="number">2</span>]))      <span class="comment"># 打印一个两行两列的1矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现矩阵的数据更改</span></span><br><span class="line">data2[<span class="number">1</span>, <span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(data2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现矩阵数据的查找</span></span><br><span class="line"><span class="built_in">print</span>(data2[<span class="number">1</span>, <span class="number">1</span>])  <span class="comment"># 或者是下面这个</span></span><br><span class="line"><span class="built_in">print</span>(data2[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵的基本运算</span></span><br><span class="line">data3 = np.ones([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(data3*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(data3/<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data3+<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data3-<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵的加法乘法</span></span><br><span class="line">data4 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(data3+data4)  <span class="comment"># 对应元素相加</span></span><br><span class="line"><span class="built_in">print</span>(data3 * data4)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1 2 3 4 5]</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">(5,) (2, 2)</span><br><span class="line">[[0. 0. 0.]</span><br><span class="line"> [0. 0. 0.]]</span><br><span class="line">[[1. 1.]</span><br><span class="line"> [1. 1.]]</span><br><span class="line">[[1 2]</span><br><span class="line"> [5 4]]</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">[[2. 2. 2.]</span><br><span class="line"> [2. 2. 2.]]</span><br><span class="line">[[0.33333333 0.33333333 0.33333333]</span><br><span class="line"> [0.33333333 0.33333333 0.33333333]]</span><br><span class="line">[[4. 4. 4.]</span><br><span class="line"> [4. 4. 4.]]</span><br><span class="line">[[-2. -2. -2.]</span><br><span class="line"> [-2. -2. -2.]]</span><br><span class="line">[[2. 3. 4.]</span><br><span class="line"> [5. 6. 7.]]</span><br><span class="line">[[1. 2. 3.]</span><br><span class="line"> [4. 5. 6.]]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>study</category>
        <category>视觉</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>tensorflow</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>apache设置反向代理</title>
    <url>/2021/09/11/apache%E8%AE%BE%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于青岛大学的OJ项目需要占用80端口，并且此服务使用的是docker来进行开展的，因此现阶段并不能找到相关的方式去更换代码，因此采用apache2的自带反代理模式，来实现对域名的映射</p>
<span id="more"></span>  

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/bluedawn/p/Apache-ReverseProxy.html">Ubuntu Apache2 反代</a></p>
<p><a href="https://blog.csdn.net/LoveZoeAyo/article/details/120228608">Ubuntu Apache反代(反向代理)设置</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/230829571">什么是反向代理？</a></p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="什么是反向代理？"><a href="#什么是反向代理？" class="headerlink" title="什么是反向代理？"></a>什么是反向代理？</h2><blockquote>
<p>反向代理是充当Web服务器网关的代理服务器。当您将请求发送到使用反向代理的Web服务器时，他们将先转到反向代理，由该代理将确定是将其路由到Web服务器还是将其阻止。</p>
<p>这意味着有了反向代理，您永远不会与使用它的Web服务器进行直接通信。可以将它们看作web服务器或服务器集群的某种包装器。通过负载平衡和缓存，它们可以保护web免遭攻击，并提供更好的web性能。</p>
</blockquote>
<h2 id="加载相关模块"><a href="#加载相关模块" class="headerlink" title="加载相关模块"></a>加载相关模块</h2><p>首先我们需要运行apache的模块加载，将下面的几个选项加载上</p>
<p><code>a2enmod proxy proxy_balancer proxy_http</code></p>
<p>之后我们需要在apahce的配置服务中设置相关配置</p>
<ol>
<li>进入到apache 的配置目录下：</li>
</ol>
<p>如我的是<code>etc/apache2/sites-available</code></p>
<ol start="2">
<li>使用你所要配置的域名进行创建一个<code>域名.conf</code>文件</li>
<li>使用vim或者等相关编辑工具对此conf文件进行编辑</li>
</ol>
<p>输入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">	ServerName lizi.com:80</span><br><span class="line">	ProxyRequests Off</span><br><span class="line">	ProxyMaxForwards 100</span><br><span class="line">	ProxyPreserveHost On</span><br><span class="line">	<span class="comment">#反代理要解析的ip 支持添加端口</span></span><br><span class="line">	ProxyPass / http://127.0.0.1:90/</span><br><span class="line">	ProxyPassReverse / http://127.0.0.1:90/</span><br><span class="line"></span><br><span class="line">	&lt;Proxy *&gt;</span><br><span class="line">		Order Deny,Allow</span><br><span class="line">		Allow from all</span><br><span class="line">	&lt;/Proxy&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：lizi.com是你的域名地址，将其替换输入进去即可</strong></p>
<ol start="4">
<li>在<code>sites-enabled</code>的文件夹下（一般是在<code>etc/apache2</code>目录下）链接一下你刚刚创建的conf文件</li>
</ol>
<p><code>ln -s /etc/apahce2/sites-available/域名.conf ../sites-enabled</code></p>
<ol start="5">
<li>之后重启apache服务便可以</li>
</ol>
<p><code>systemctl restart apache2</code>或者<code>service apache2 restart</code></p>
<p>然后访问你的域名，你就会发现已经正常代理到了你所需要的网站上</p>
<h1 id="相关用途"><a href="#相关用途" class="headerlink" title="相关用途"></a>相关用途</h1><ul>
<li><strong>该公司可以隐藏其实际内部服务器结构的详细信息</strong>，从而使访问或破坏这些服务器变得更加困难。本质上是黑客保护。</li>
<li>**反向代理可以使用防火墙设置来帮助防御<a href="https://link.zhihu.com/?target=https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/">DDoS攻击</a>**。该代理可以减轻DDoS的压力并通过合法的流量，而不会损害真实Web服务器的性能。当然，就像一扇人群挤过的门一样，它仍然可能是一个瓶颈，但并不是那种在失败时危及用户数据的瓶颈。</li>
<li><strong>反向代理可能配备有可加快SSL证书验证速度的硬件</strong>，从而使SSL连接更快且更不容易被利用。</li>
<li>如果有几台内部Web服务器上有冗余数据，<strong>则反向代理可以充当负载平衡器</strong>，确保每台内部服务器的压力都不大。当每台服务器的功能极小但它们共同构成强大的资源来源时，此功能特别有用。</li>
<li>通过在请求相同时立即向多个客户端提供动态数据，<strong>可以将反向代理用作动态内容的缓存</strong>。此过程称为网络加速。</li>
<li><strong>反向代理可以处理</strong> Web服务器的<strong>数据压缩</strong>，以提供更快的连接和较低的主Web服务器压力。</li>
<li>当访问地址必须保持不变时，<strong>反向代理用于统一网址</strong>。如果您有五个Web服务器，则通常每个服务器都有自己的IP地址。这将使静态脚本难以访问，因为它将被迫访问指</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Apache2</tag>
      </tags>
  </entry>
  <entry>
    <title>arduino安装库(线下)</title>
    <url>/2021/07/16/arduino%E5%AE%89%E8%A3%85%E5%BA%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于部分库的获得需要通过国外网站，而对于培训来讲，让每个人翻墙不太好，因此出此文章</p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="下载所需库"><a href="#下载所需库" class="headerlink" title="下载所需库"></a>下载所需库</h2><p>通过任意渠道去获取到你所需要的库，包括但不限于直接上github上下载、找学长学姐要、网盘里有提供，总之下载下来解压好便可以</p>
<h2 id="安装所需库"><a href="#安装所需库" class="headerlink" title="安装所需库"></a>安装所需库</h2><p>将所下载好的安装包解压，我们会得到如下文件夹</p>
<p><img src="https://user-images.githubusercontent.com/40520292/125896645-9864ac96-53a4-4528-9949-56f279f57815.png" alt="image"></p>
<p>之后将这些文件夹统一放置在arduinio安装的目录下的libries，比如我的是<code>F:\arduino\libraries</code>：</p>
<p><img src="https://user-images.githubusercontent.com/40520292/125896875-70755954-cdc7-4877-9c3f-ba936e9b8a64.png" alt="image"></p>
<p>之后重启arduino便可以</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>打开arduino，看看是不是会多出来这些库呢？</p>
]]></content>
      <categories>
        <category>study</category>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>esp8266</tag>
        <tag>arduino</tag>
      </tags>
  </entry>
  <entry>
    <title>cv实现图片裁剪以及移位</title>
    <url>/2021/07/28/cv%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E4%BB%A5%E5%8F%8A%E7%A7%BB%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想跟着b站大佬，去学习一些相关知识</p>
<p>使用opencv对图像进行裁剪以及移位</p>
<span id="more"></span>

<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="图片剪切"><a href="#图片剪切" class="headerlink" title="图片剪切"></a>图片剪切</h2><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片剪切功能</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">imgInfo = img.shape</span><br><span class="line">dst = img[<span class="number">3000</span>:<span class="number">3600</span>, <span class="number">3100</span>:<span class="number">3700</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p>原图：</p>
<p><img src="https://user-images.githubusercontent.com/40520292/127297201-c871ae9d-7d1d-4fb6-820c-391885d06f04.png" alt="image"></p>
<p>处理后：</p>
<p><img src="https://user-images.githubusercontent.com/40520292/127297221-9a843eb7-9783-4c2a-bd33-9a739c03839c.png" alt="image"></p>
<h2 id="使用API的方式对图片进行位移"><a href="#使用API的方式对图片进行位移" class="headerlink" title="使用API的方式对图片进行位移"></a>使用API的方式对图片进行位移</h2><h3 id="代码部分-1"><a href="#代码部分-1" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># cv2.imshow(&#x27;src&#x27;, img)</span></span><br><span class="line">imgInfo = img.shape</span><br><span class="line">imgH = imgInfo[<span class="number">0</span>]</span><br><span class="line">imgW = imgInfo[<span class="number">1</span>]</span><br><span class="line">matShift = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">200</span>]])</span><br><span class="line">dst = cv2.warpAffine(img, matShift, (imgH, imgW))</span><br><span class="line"><span class="comment"># 参数1：原始图片信息 参数2：移位矩阵 参数3：相关信息</span></span><br><span class="line">cv2.namedWindow(<span class="string">&quot;enhanced&quot;</span>, cv2.WINDOW_FREERATIO)</span><br><span class="line"><span class="comment"># 如果图片特别大，可以采用以上方法</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;enhanced&quot;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>原图：</p>
<p><img src="https://user-images.githubusercontent.com/40520292/127297242-0cf6465f-54d6-43a4-af48-3908cc0ea422.png" alt="image"></p>
<p>运行结果：</p>
<p><img src="https://user-images.githubusercontent.com/40520292/127297265-76b1cf71-2a00-40a4-87d1-7446ea3ffad2.png" alt="image"></p>
<p>可以看见图像明显的进行了移位</p>
<h2 id="使用源码的形式对图片进行位移"><a href="#使用源码的形式对图片进行位移" class="headerlink" title="使用源码的形式对图片进行位移"></a>使用源码的形式对图片进行位移</h2><h3 id="代码部分-2"><a href="#代码部分-2" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;YT&quot;</span>, cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;YT&#x27;</span>, img)</span><br><span class="line">imgInfo = img.shape</span><br><span class="line">dst = np.zeros(img.shape, np.uint8)</span><br><span class="line">height = imgInfo[<span class="number">0</span>]</span><br><span class="line">weight = imgInfo[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, height):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, weight-<span class="number">100</span>):</span><br><span class="line">        dst[i][j+<span class="number">100</span>] = img[i, j]</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;img&quot;</span>, cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://user-images.githubusercontent.com/40520292/127297283-28a10011-e71e-4ace-8965-70d9b053aad5.png" alt="image"></p>
<p>左边为原图，右边为移动后的图片（由于图片过大，因此放大了一下）</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如果原图太大，当前屏幕无法进行显示"><a href="#如果原图太大，当前屏幕无法进行显示" class="headerlink" title="如果原图太大，当前屏幕无法进行显示"></a>如果原图太大，当前屏幕无法进行显示</h2><p>可以在<code>imshow()</code>方法前面加入<code>cv2.namedWindow(&quot;enhanced&quot;, cv2.WINDOW_FREERATIO)</code>，便可实现窗口自适应并可以进行相关放缩</p>
]]></content>
      <categories>
        <category>study</category>
        <category>视觉</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>esp8266(贴片)使用ttl烧录程序</title>
    <url>/2021/07/18/esp8266(%E8%B4%B4%E7%89%87)%E4%BD%BF%E7%94%A8ttl%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于实验室以及小学期培训所用到的芯片是贴片芯片，并没有mirco usb来进行编写烧录，需要在烧录前做一些准备，因此出一篇博客，顺便学习一下esp8266（贴片）的相关信息</p>
<span id="more"></span>
<h1 id="相关参考资料"><a href="#相关参考资料" class="headerlink" title="相关参考资料"></a>相关参考资料</h1><p><a href="https://blog.csdn.net/qq_36958104/article/details/103406214?spm=1001.2014.3001.5506">ESP8266下载AT固件</a></p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="看引脚图"><a href="#看引脚图" class="headerlink" title="看引脚图"></a>看引脚图</h2><p>首先需要查看一下esp8266（贴片）的引脚图，根据引脚图功能，以及网上的相关参考文件，对线路进行焊接<br><img src="https://user-images.githubusercontent.com/40520292/126067535-a7e74406-c8bf-4c50-8235-9b5288c6df91.png" alt="引脚图"><br>【图源必应】</p>
<h2 id="查询相关资料"><a href="#查询相关资料" class="headerlink" title="查询相关资料"></a>查询相关资料</h2><p>ESP8266的相关引脚</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">引脚标号</th>
<th align="center">引脚作用</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">GND</td>
<td align="center">地</td>
<td align="center">接电源负极或者io口置零使用</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">VCC</td>
<td align="center">电源正极</td>
<td align="center">一般为3.3V，外部供电使用</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">RST</td>
<td align="center">复位</td>
<td align="center">外部复位引脚，低电平复位</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">RXD</td>
<td align="center">数据接收端</td>
<td align="center">用于数据传输</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">TXD</td>
<td align="center">数据发送端</td>
<td align="center">用于数据传输</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">GPIO0</td>
<td align="center">工作模式选择</td>
<td align="center">当高电平为工作模式；当为低电平为下载模式</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">GPIO15</td>
<td align="center">SS (SPI)</td>
<td align="center">运行以及编译时保持低电平</td>
</tr>
</tbody></table>
<p>在运行过程种，我们只需要对vcc以及gnd进行接线便可以使用，并不需要外接其他IO口<br>因此我们在烧录程序之前先要对手上的芯片进行接线<br><strong>请注意：esp8266（贴片并无内置上拉电阻，因此为确保安全，请在危险操作时接入上拉电阻）</strong></p>
<h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><p><img src="https://user-images.githubusercontent.com/40520292/126068460-ff83639f-f107-4c2a-9384-0bbd9cff5ce2.jpg" alt="1626614185608"><br>接线前</p>
]]></content>
      <categories>
        <category>study</category>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>esp8266</tag>
      </tags>
  </entry>
  <entry>
    <title>使用tf进行基本的矩阵运算</title>
    <url>/2021/07/26/tf%E8%BF%9B%E8%A1%8C%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试根据b站大佬来扩充自己的知识面</p>
<p>本人使用的环境为tf2.0但是b站视频是1.0，因此与视频会稍有不符合</p>
<span id="more"></span>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1QJ411W7SS?p=15">B站视频</a></p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="代码片段1"><a href="#代码片段1" class="headerlink" title="代码片段1"></a>代码片段1</h2><p>这里仅贴出跟着b站视频写出来的代码，并在有些区域会有些许注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment"># data1 = tf.placeholder(tf.float32)        # 该方法在2.0版本之后就已经被弃用</span></span><br><span class="line"><span class="comment"># data2 = tf.placeholder(tf.float32)        # 该方法在2.0版本之后就已经被弃用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.0之后使用</span></span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># 初始化新版本的模块化更新信息</span></span><br><span class="line"></span><br><span class="line">data1 = tf.compat.v1.placeholder(tf.float32)</span><br><span class="line">data2 = tf.compat.v1.placeholder(tf.float32)</span><br><span class="line">dataAdd = tf.add(data1, data2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># with tf.sesson() as sess: # 该方法已经在2.0之后弃用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.0之后使用</span></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(dataAdd,  feed_dict=&#123;data1: <span class="number">6</span>, data2: <span class="number">2</span>&#125;))</span><br><span class="line">    <span class="comment"># feed_dict 为其中的内容进行赋值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8.0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="代码片段2"><a href="#代码片段2" class="headerlink" title="代码片段2"></a>代码片段2</h2><p>此部分代码表明Python的矩阵维度定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># 初始化新版本的模块化更新信息</span></span><br><span class="line"></span><br><span class="line">data1 = tf.compat.v1.constant([[<span class="number">6</span>, <span class="number">6</span>]])  <span class="comment"># 一行两列</span></span><br><span class="line">data2 = tf.compat.v1.constant([[<span class="number">2</span>], [<span class="number">2</span>]])  <span class="comment"># 两行一列</span></span><br><span class="line">data3 = tf.compat.v1.constant([[<span class="number">3</span>, <span class="number">3</span>]])  <span class="comment"># 一行两列</span></span><br><span class="line">data4 = tf.compat.v1.constant([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])  <span class="comment"># 三行两列</span></span><br><span class="line">data5 = tf.compat.v1.constant([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                               [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                               [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])  <span class="comment"># 三行三列，为了更好区分，因此加了回车</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data5.shape)  <span class="comment"># 打印矩阵维度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(data5))  <span class="comment"># 输出整个矩阵</span></span><br><span class="line">    <span class="built_in">print</span>(sess.run(data5[<span class="number">0</span>]))  <span class="comment"># 输出矩阵的某一行</span></span><br><span class="line">    <span class="built_in">print</span>(sess.run(data5[:, <span class="number">0</span>]))  <span class="comment"># 输出矩阵的某一列</span></span><br><span class="line">    <span class="built_in">print</span>(sess.run(data5[<span class="number">0</span>][<span class="number">0</span>]))  <span class="comment"># 输出矩阵第一行第一列</span></span><br><span class="line"><span class="comment"># 矩阵的起始位置都是0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(3, 3)</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]</span><br><span class="line"> [7 8 9]]</span><br><span class="line">[1 2 3]</span><br><span class="line">[1 4 7]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>片段</p>
<h2 id="代码片段3"><a href="#代码片段3" class="headerlink" title="代码片段3"></a>代码片段3</h2><p>此段代码讲解矩阵乘法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 矩阵乘法</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;TF_CPP_MIN_LOG_LEVEL&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># 初始化新版本的模块化更新信息</span></span><br><span class="line"></span><br><span class="line">data1 = tf.compat.v1.constant([[<span class="number">6</span>, <span class="number">6</span>]])  <span class="comment"># 一行两列</span></span><br><span class="line">data2 = tf.compat.v1.constant([[<span class="number">2</span>], [<span class="number">2</span>]])  <span class="comment"># 两行一列</span></span><br><span class="line">data3 = tf.compat.v1.constant([[<span class="number">3</span>, <span class="number">3</span>]])  <span class="comment"># 一行两列</span></span><br><span class="line">data4 = tf.compat.v1.constant([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])  <span class="comment"># 三行两列</span></span><br><span class="line">data5 = tf.compat.v1.constant([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                               [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                               [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])  <span class="comment"># 三行三列，为了更好区分，因此加了回车</span></span><br><span class="line">matMul = tf.matmul(data1, data2)</span><br><span class="line">matMul2 = tf.multiply(data1, data2)     <span class="comment"># 类似于加法，对应元素相乘</span></span><br><span class="line">matAdd = tf.add(data1, data3)</span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(matMul))     <span class="comment"># 一维</span></span><br><span class="line">    <span class="built_in">print</span>(sess.run(matAdd))     <span class="comment"># 二维</span></span><br><span class="line">    <span class="built_in">print</span>(sess.run(matMul2))</span><br><span class="line">    <span class="built_in">print</span>(sess.run([matMul, matAdd]))   <span class="comment"># 可以通过中括号，一次性打印多个内容</span></span><br><span class="line"><span class="comment"># MK x KN = MN</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[24]]</span><br><span class="line">[[9 9]]</span><br><span class="line">[[12 12]</span><br><span class="line"> [12 12]]</span><br><span class="line">[array([[24]], dtype=int32), array([[9, 9]], dtype=int32)]</span><br></pre></td></tr></table></figure>



<h2 id="代码片段4"><a href="#代码片段4" class="headerlink" title="代码片段4"></a>代码片段4</h2><p>如何定义一个基本矩阵</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;TF_CPP_MIN_LOG_LEVEL&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># 初始化新版本的模块化更新信息</span></span><br><span class="line"></span><br><span class="line">mat0 = tf.constant([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])  <span class="comment"># 自己动手，丰衣足食</span></span><br><span class="line">mat1 = tf.zeros([<span class="number">2</span>, <span class="number">3</span>])     <span class="comment"># 定义一个三行两列的空矩阵</span></span><br><span class="line">mat2 = tf.ones([<span class="number">3</span>, <span class="number">2</span>])      <span class="comment"># 定义一个三行两列的1矩阵</span></span><br><span class="line">mat3 = tf.fill([<span class="number">2</span>, <span class="number">3</span>], <span class="number">15</span>)</span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat0))</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat1))</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat2))</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat3))</span><br></pre></td></tr></table></figure>



<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[0 0 0]</span><br><span class="line"> [0 0 0]]</span><br><span class="line">[[0. 0. 0.]</span><br><span class="line"> [0. 0. 0.]]</span><br><span class="line">[[1. 1.]</span><br><span class="line"> [1. 1.]</span><br><span class="line"> [1. 1.]]</span><br><span class="line">[[15 15 15]</span><br><span class="line"> [15 15 15]]</span><br></pre></td></tr></table></figure>



<h2 id="代码片段5"><a href="#代码片段5" class="headerlink" title="代码片段5"></a>代码片段5</h2><p>如何定义一个非基本矩阵</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如何定义一个矩阵（非基础）</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;TF_CPP_MIN_LOG_LEVEL&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># 初始化新版本的模块化更新信息</span></span><br><span class="line"></span><br><span class="line">mat1 = tf.constant([[<span class="number">2</span>], [<span class="number">3</span>], [<span class="number">4</span>]])</span><br><span class="line">mat2 = tf.zeros_like(mat1)  <span class="comment"># 定义一个全零矩阵，维度与mat1相同</span></span><br><span class="line">mat3 = tf.linspace(<span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">11</span>)    <span class="comment"># 创建一个从0-2的一个中间具有11个元素的矩阵</span></span><br><span class="line">mat4 = tf.compat.v1.random_uniform([<span class="number">2</span>, <span class="number">3</span>], -<span class="number">1</span>, <span class="number">2</span>)   <span class="comment"># 创建一个2×3的矩阵，并且矩阵数字为 (-1)-2 之间</span></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat2))</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat3))</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat4))</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[0]</span><br><span class="line"> [0]</span><br><span class="line"> [0]]</span><br><span class="line">[0.        0.2       0.4       0.6       0.8       1.        1.2</span><br><span class="line"> 1.4       1.6       1.8000001 2.       ]</span><br><span class="line">[[-0.988165   0.3698578 -0.68531  ]</span><br><span class="line"> [-0.7001637  1.0496833  1.1087246]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="在tf中矩阵的定义"><a href="#在tf中矩阵的定义" class="headerlink" title="在tf中矩阵的定义"></a>在tf中矩阵的定义</h2><p>在python中，定义一个矩阵可以采用以下方法进行定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python中矩阵的定义</span></span><br><span class="line"><span class="comment"># 一行两列:[[6,6]]</span></span><br><span class="line"><span class="comment"># 两行两列:[[6,6],[6,6]]</span></span><br></pre></td></tr></table></figure>



<h2 id="什么是placeholder"><a href="#什么是placeholder" class="headerlink" title="什么是placeholder"></a>什么是<code>placeholder</code></h2><blockquote>
<p>Tensorflow中的palceholder，中文翻译为占位符，什么意思呢？</p>
<p>在Tensoflow2.0以前，还是静态图的设计思想，整个设计理念是计算流图，在编写程序时，首先构筑整个系统的graph，代码并不会直接生效，这一点和python的其他数值计算库（如Numpy等）不同，graph为静态的，在实际的运行时，启动一个session，程序才会真正的运行。这样做的好处就是：避免反复地切换底层程序实际运行的上下文，tensorflow帮你优化整个系统的代码。我们知道，很多python程序的底层为C语言或者其他语言，执行一行脚本，就要切换一次，是有成本的，tensorflow通过计算流图的方式，可以帮你优化整个session需要执行的代码。</p>
<p>在代码层面，每一个tensor值在graph上都是一个op，当我们将train数据分成一个个minibatch然后传入网络进行训练时，每一个minibatch都将是一个op，这样的话，一副graph上的op未免太多，也会产生巨大的开销；于是就有了tf.placeholder()，我们每次可以将 一个minibatch传入到x = tf.placeholder(tf.float32,[None,32])上，下一次传入的x都替换掉上一次传入的x，这样就对于所有传入的minibatch x就只会产生一个op，不会产生其他多余的op，进而减少了graph的开销。<br>——<a href="https://blog.csdn.net/caoyuan666/article/details/104706756">CSDN</a></p>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h2><h4 id="报错信息为AttributeError-module-39-tensorflow-39-has-no-attribute-39-placeholder-39"><a href="#报错信息为AttributeError-module-39-tensorflow-39-has-no-attribute-39-placeholder-39" class="headerlink" title="报错信息为AttributeError: module &#39;tensorflow&#39; has no attribute &#39;placeholder&#39;"></a>报错信息为<code>AttributeError: module &#39;tensorflow&#39; has no attribute &#39;placeholder&#39;</code></h4><p>由于本人使用的环境不同，根据<a href="https://blog.csdn.net/caoyuan666/article/details/104706756">CSDN</a>上的信息而言，表明在tf版本2.0之后，该方法就已经被进行了弃用，因此我们需要寻找到2.0版本的对应方法，对应方法已经在相关代码片段中进行提及</p>
]]></content>
      <categories>
        <category>study</category>
        <category>视觉</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>从零搭建树莓派</title>
    <url>/2021/07/28/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%A0%91%E8%8E%93%E6%B4%BE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章只是记录一下自己从零开始搭建树莓派的辛酸历程，对自己出现以及产生的问题做了个汇总。其中内部有些资源是查到了大佬的解决方法之后懂得了了解的，相关问题的源链接会放在文章底。<br>本篇文章搬运于自己CSDN</p>
<span id="more"></span>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="树莓派wifi配置（linux系统）"><a href="#树莓派wifi配置（linux系统）" class="headerlink" title="树莓派wifi配置（linux系统）"></a>树莓派wifi配置（linux系统）</h3><p>本方法运用于树莓派没有相关hdmi接口只能使用vnc进行链接的方法<br>将树莓派上的tf卡拔下来，插到电脑上<br>使用管理员权限打开<code>/rootfs/etc/wpa_supplicant</code><br>然后使用文本编辑器打开其中的wpa_supplicant.conf文件（没有的需要自己创建）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update_config=1</span><br><span class="line">country=CN</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">	ssid=&quot;wifi名称&quot;</span><br><span class="line">	psk=&quot;wifi密码&quot;</span><br><span class="line">	#自己wifi的加密方式（一般有密码的是下面这个）</span><br><span class="line">	key_mgmt=WPA-PSK</span><br><span class="line">&#125;</span><br><span class="line">#如果有其他的可以设置下面的，没有可以删掉</span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=“wifi名称”</span><br><span class="line">        psk=&quot;wifi密码“</span><br><span class="line">        key_mgmt=WPA-PSK</span><br><span class="line">&#125;</span><br><span class="line">#wifi没有密码：</span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=&quot;testing&quot;</span><br><span class="line">    key_mgmt=NONE</span><br><span class="line">&#125;</span><br><span class="line">#你的WIFI是隐藏wifi:</span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=&quot;yourHiddenSSID&quot;</span><br><span class="line">    scan_ssid=1</span><br><span class="line">    psk=&quot;Your_wifi_password&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后保存文件之后将tf卡插入回树莓派启动之后便可以发现你的树莓派连接到wifi了</p>
<h3 id="树莓派换源"><a href="#树莓派换源" class="headerlink" title="树莓派换源"></a>树莓派换源</h3><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>由于身处国内，所以要从外网get资料并不是那么容易，因此我们需要将树莓派进行换源，达到下载相关软件包的速度快捷。<br>使用命令：<br><code>lsb_release -a</code>    查询自己的树莓派属于哪个版本<br><img src="https://img-blog.csdnimg.cn/20210203094734646.png" alt="版本对应"><br>发现自己版本属于buster版本<br>之后使用以下命令<br><code>sudo nano /etc/apt/source.list</code><br>然后将里面的源进行注释掉，之后找到相关对应版本的国内源（清华啥的），之后进行替换即可。<br>之后运行下面的命令将相关包进行更新<br><code>sudo apt update </code>    从源获取相关的更新包<br><code>sudo apt upgrade</code>    进行更新</p>
<p>PS：其中nano为文本编辑器，我不知道怎么从外面复制内容到这个编辑器里面，所以一般我直接采用将tf卡直接插到电脑上进行修改（需要电脑系统是linux，windows系统不支持树莓派的系统盘格式）</p>
<h3 id="会出现的问题"><a href="#会出现的问题" class="headerlink" title="会出现的问题"></a>会出现的问题</h3><p>如果你的源版本与你的树莓派系统版本不对应的话，则会出现依赖错误，导致你后面安装啥也安装不了<br><img src="https://img-blog.csdnimg.cn/20210203095054961.png" alt="血泪史"></p>
<h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>孩子只是一个萌新小白，对于自身发现的问题以及相关问题在网上搜了好久也没找到，所以自力更生，防止自己以后忘记，留个备注，如有错误还望多多海涵～</p>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="linux查询你的wifi名称及密码"><a href="#linux查询你的wifi名称及密码" class="headerlink" title="linux查询你的wifi名称及密码"></a>linux查询你的wifi名称及密码</h3><p>命令如下：<br><code>cd /etc/NetworkManager/system-connections</code><br><code>ls</code><br><code>sudo cat 你想查询的wifi名称</code><br>PS：网上教程，原问题搜不到了，这个方法没查出来过wifi密码，有待改进</p>
<h2 id="后续更新"><a href="#后续更新" class="headerlink" title="后续更新"></a>后续更新</h2><h3 id="2021-03-05更新"><a href="#2021-03-05更新" class="headerlink" title="2021/03/05更新"></a>2021/03/05更新</h3><p>现在访问使用树莓派更新会面临着更新系统的问题，然后也是官方源，感觉好慢因此<br>终端中输入下面这个命令进入树莓派系统源的地方</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>apt<span class="regexp">/sources.list.d/</span>raspi.list</span><br></pre></td></tr></table></figure>
<p>将上面的那个注释掉，并且加入下面的</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">deb http:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/raspberrypi/</span> buster main ui</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<br>以上源适用于buster版本的树莓派系统，系统不符可能会造成依赖问题</p>
</blockquote>
<h2 id="相关原问题以及解答"><a href="#相关原问题以及解答" class="headerlink" title="相关原问题以及解答"></a>相关原问题以及解答</h2><p>树莓派换源以及依赖问题：<a href="https://blog.csdn.net/fightingboom/article/details/106879019?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-7&spm=1001.2101.3001.4242">点我</a><br>树莓派wifi配置：<a href="https://blog.csdn.net/bona020/article/details/79038914">点我</a><br>有一个讲的比较好的<a href="https://blog.csdn.net/weixin_45985341/article/details/113780422?spm=1001.2014.3001.5501">here</a><br>镜像源推荐<a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/">清华源</a></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>使用github action对gitee进行同步</title>
    <url>/2021/07/18/%E4%BD%BF%E7%94%A8github%20action%E5%AF%B9gitee%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近发现github action可以做好多的事情，尝试使用这个东西来将自己的两个仓库内容进行同步  </p>
<span id="more"></span>
<p>即使可以在本地的配置文件，将仓库同时关注到本地仓库上，但是如果更换仓库或者更换设备之后，就得重新配置，这不够懒，因此不符合我的想法，因此制作一个文章来记录一下相关操作  </p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/ssgeek/p/15009012.html">使用github action实现github到gitee的代码同步</a></p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><strong>先鸽着，等我下次换到linux上在写</strong>，如有急用可以看上面的，大概看了一下，问题不大</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>github action</tag>
      </tags>
  </entry>
  <entry>
    <title>使用opencv对图像进行缩放</title>
    <url>/2021/07/28/%E4%BD%BF%E7%94%A8opencv%E5%AF%B9%E5%9B%BE%E5%83%8F%E8%BF%9B%E8%A1%8C%E7%BC%A9%E6%94%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试根据b站大佬的相关视频，扩展自己的知识面以及知识水平</p>
<span id="more"></span>

<h1 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h1><p><a href="https://www.bilibili.com/video/BV1QJ411W7SS?p=25">b站视频</a></p>
<p><a href="https://blog.csdn.net/qq_40317204/article/details/105614120">最近临域插值</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/110754637">相关介绍</a></p>
<p><a href="https://www.cnblogs.com/sycy/p/4743620.html">双线性插值</a></p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="现阶段图片缩放类型及相关方法"><a href="#现阶段图片缩放类型及相关方法" class="headerlink" title="现阶段图片缩放类型及相关方法"></a>现阶段图片缩放类型及相关方法</h2><h3 id="最近临域插值"><a href="#最近临域插值" class="headerlink" title="最近临域插值"></a>最近临域插值</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>假设原图像为10x20的图片，而想要将其缩放成为5x10的图片</p>
<p>使用目标图像的点，去表示原图像的点</p>
<p>​        （1,2） —&gt;        （2,4）</p>
<p>如何使用目标图像的点去推断原图像的点</p>
<p><code>newX = x*(原图像的行/目标图像的行)</code></p>
<p><code>newY = y*(原图像的列/目标图像的列)</code></p>
<p>注：如出现小数，需要取整</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>目标各像素点的灰度值代替源图像中与其最邻近像素的灰度值。</p>
<h4 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><ul>
<li>算法简单</li>
<li>相比于其他方法可以更好的去实现</li>
<li>容易出现色块现象</li>
<li>会破坏原图像的渐变关系</li>
</ul>
<h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="https://user-images.githubusercontent.com/40520292/127262583-c546b29e-f01d-4063-bbf2-a2e90beea45f.png" alt="image"></p>
<p><code>A1 = 20%上面的点 +80%下面的点</code></p>
<p><code>B1 = 30%左面的点 +70%右边的点</code></p>
<p><code>1最终点 = A1*30% + A2*70%</code></p>
<p> <code>2最终点 = B1*20% + B2*80%</code></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>双线性插值，又称为双线性内插。在数学上，双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值</p>
<h4 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><ul>
<li>内插值法计算量大</li>
<li>图像质量高，不会出现不连续的现象</li>
<li>具有低通滤波性质，可能会使得图像在一定程度上变得模糊</li>
</ul>
<h2 id="使用双线性插值对图像进行缩放处理"><a href="#使用双线性插值对图像进行缩放处理" class="headerlink" title="使用双线性插值对图像进行缩放处理"></a>使用双线性插值对图像进行缩放处理</h2><h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">imgInfo = img.shape     <span class="comment"># 获取图片信息</span></span><br><span class="line"><span class="built_in">print</span>(imgInfo)</span><br><span class="line">height = imgInfo[<span class="number">0</span>]     <span class="comment"># 图片高度</span></span><br><span class="line">weight = imgInfo[<span class="number">1</span>]     <span class="comment"># 图片宽度</span></span><br><span class="line">mode = imgInfo[<span class="number">2</span>]      <span class="comment"># 图片的组成方式</span></span><br><span class="line"><span class="comment"># 缩放:放大或者缩小     等比例或者非等比例</span></span><br><span class="line">dstHeight = <span class="built_in">int</span>(height*<span class="number">0.5</span>)</span><br><span class="line">dstWeight = <span class="built_in">int</span>(weight*<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片缩放类型： 最近临域插值    双线性插值（默认）   像素关系重采样     立方插值</span></span><br><span class="line">dst = cv2.resize(img, (dstWeight, dstHeight))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(3648, 2736, 3)</span><br></pre></td></tr></table></figure>

<p>原图：</p>
<p><img src="https://user-images.githubusercontent.com/40520292/127262602-7abc7bc3-10d8-4410-a75a-223a1e88590f.png" alt="image">  </p>
<p>运行结果：</p>
<p><img src="https://user-images.githubusercontent.com/40520292/127262621-e7cc2d88-e168-46e7-aba0-cffd88ed90c6.png" alt="image">  </p>
<h2 id="最近临域插值法实现照片缩放"><a href="#最近临域插值法实现照片缩放" class="headerlink" title="最近临域插值法实现照片缩放"></a>最近临域插值法实现照片缩放</h2><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li>先获取当前图片的信息</li>
<li>使用numpy创建一个空白模板</li>
<li>重新加载对应的图片</li>
</ol>
<h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">效果<span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">imgInfo = img.shape</span><br><span class="line">imgHeight = imgInfo[<span class="number">0</span>]</span><br><span class="line">imgWeight = imgInfo[<span class="number">1</span>]</span><br><span class="line">dstHeight = <span class="built_in">int</span>(imgHeight / <span class="number">2</span>)</span><br><span class="line">dstWeight = <span class="built_in">int</span>(imgWeight/<span class="number">2</span>)</span><br><span class="line">dstImg = np.zeros((dstHeight, dstWeight, <span class="number">3</span>), np.uint8)   <span class="comment"># 0-255</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dstHeight):       <span class="comment"># 对应的是行信息</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dstWeight):   <span class="comment"># 对应的是列信息</span></span><br><span class="line">        iNew = <span class="built_in">int</span>(i*(imgHeight*<span class="number">1.0</span>/dstHeight))</span><br><span class="line">        jNew = <span class="built_in">int</span>(j*(imgWeight*<span class="number">1.0</span>/dstWeight))</span><br><span class="line">        dstImg[i, j] = img[iNew, jNew]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dstImg)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p>原图：</p>
<p><img src="https://user-images.githubusercontent.com/40520292/127262608-6f5eda7e-a080-4c99-9db9-5c33fd90ac6c.png" alt="image">  </p>
<p>缩放后图片：</p>
<p><img src="https://user-images.githubusercontent.com/40520292/127262628-e988e823-6060-4d9c-94b2-26a6c13394e9.png" alt="image"></p>
]]></content>
      <categories>
        <category>study</category>
        <category>视觉</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>图片仿射变换</title>
    <url>/2021/08/18/%E5%9B%BE%E5%83%8F%E7%9A%84%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想跟着b站大佬，去学习一些相关知识</p>
<p>使用opencv对图像进行仿射变换</p>
<span id="more"></span>

<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="什么是仿射变换"><a href="#什么是仿射变换" class="headerlink" title="什么是仿射变换"></a>什么是仿射变换</h2><p>通过将原图片上的三个点经过相关变换去映射到目标图片的三个点的变化，属于线性变换<br>仿射变换保持了二维图像的“平直性”和“平行性”  </p>
<p>其中：三个点分别为：</p>
<ul>
<li>左上角</li>
<li>左下角</li>
<li>右下角</li>
</ul>
<h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;src&quot;</span>, cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;src&#x27;</span>, img)</span><br><span class="line">imgInfo = img.shape</span><br><span class="line">height = imgInfo[<span class="number">0</span>]</span><br><span class="line">weight = imgInfo[<span class="number">1</span>]</span><br><span class="line">matSrc = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, weight-<span class="number">1</span>], [height-<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">matDst = np.float32([[<span class="number">100</span>, <span class="number">100</span>], [<span class="number">300</span>, height], [weight-<span class="number">300</span>, <span class="number">100</span>]])</span><br><span class="line">matAffine = cv2.getAffineTransform(matSrc, matDst)</span><br><span class="line"><span class="comment"># 得到的是一个矩阵的组合</span></span><br><span class="line">dst = cv2.warpAffine(img, matAffine, (weight, height))</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;dst&quot;</span>, cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="原图"><a href="#原图" class="headerlink" title="原图"></a>原图</h3><p><img src="https://user-images.githubusercontent.com/40520292/129829784-50082f62-fa96-4522-8ed2-50e67d11ba08.png" alt="image"></p>
<h3 id="运行结果图"><a href="#运行结果图" class="headerlink" title="运行结果图"></a>运行结果图</h3><p><img src="https://user-images.githubusercontent.com/40520292/129829800-2cfedcba-ca76-41cb-9563-3aa00d9aa0e7.png" alt="image"></p>
]]></content>
      <categories>
        <category>study</category>
        <category>视觉</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现linux终端代理</title>
    <url>/2021/09/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0linux%E7%9A%84%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于部分终端命令需要从github上进行下载，然而限于国内网速过慢，因此探寻一高方法，可以让终端去使用代理</p>
<span id="more"></span>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://v2raytech.com/linux-cmd-set-proxy/">Linux终端设置代理</a></p>
<p><a href="https://www.dailiproxy.com/proxy-vpn/">代理与VPN的区别</a></p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="代理与VPN的区别"><a href="#代理与VPN的区别" class="headerlink" title="代理与VPN的区别"></a>代理与VPN的区别</h2><p>未完待续</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>如何简单的安装arduino以及esp8266相关库</title>
    <url>/2021/07/21/%E5%A6%82%E4%BD%95%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%89%E8%A3%85arduino%E4%BB%A5%E5%8F%8Aesp8266%E7%9B%B8%E5%85%B3%E5%BA%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这就是一个很简单的安装教程，相信我，很简单。。。</p>
<span id="more"></span>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul>
<li>首先<a href="https://www.jianshu.com/p/0bc77e7078e2">安装arduino</a>【安装教程参考部分便好】</li>
<li>其次需要<a href="https://zhycarge.github.io/2021/07/14/esp8266%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#more">安装esp8266相关库</a>  </li>
<li>如果正常流程安装不了库文件，可以采用我们库进行安装，<a href="https://zhycarge.github.io/2021/07/16/arduino%E5%AE%89%E8%A3%85%E5%BA%93/">点我查看</a></li>
<li>之后我们需要<a href="https://zhycarge.github.io/2021/07/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8esp8266/#more">尝试编译一次代码</a>【只需要检查相关库是否存在，不需要烧录到芯片】<h1 id="相关资料参考"><a href="#相关资料参考" class="headerlink" title="相关资料参考"></a>相关资料参考</h1><img src="https://user-images.githubusercontent.com/40520292/126493721-63adff26-bfb1-46ff-8530-5d811b197a9b.png" alt="image"></li>
</ul>
<p>【arduino安装包位置】  </p>
<p><img src="https://user-images.githubusercontent.com/40520292/126493844-f6e941db-8bde-4446-b138-1acc9c04b07f.png" alt="image"><br>【esp8266相关库文件位置】</p>
]]></content>
      <categories>
        <category>study</category>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>esp8266</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫简介</title>
    <url>/2021/08/22/%E7%88%AC%E8%99%AB%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>网络爬虫（又称为网页蜘蛛，<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C/143243">网络</a>机器人，在<a href="https://baike.baidu.com/item/FOAF">FOAF</a>社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/13831935">程序</a>或者<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC/1697005">脚本</a>。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。</p>
<p>​                                                                                    ——百度百科</p>
</blockquote>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="爬虫的相关分类"><a href="#爬虫的相关分类" class="headerlink" title="爬虫的相关分类"></a>爬虫的相关分类</h2><ul>
<li>通用爬虫</li>
</ul>
<p>抓取系统重要的组成部分，抓取的是一整张页面</p>
<ul>
<li>聚焦爬虫</li>
</ul>
<p>建立在通用爬虫基础之上，抓取页面中特定的局部内容</p>
<ul>
<li>增量式爬虫</li>
</ul>
<p>检测网站中数据更新的情况，只会抓取网站中最新出来的数据</p>
<h2 id="反爬机制"><a href="#反爬机制" class="headerlink" title="反爬机制"></a>反爬机制</h2><p>可以制定相关策略或者相关技术手段，可以防止爬虫程鑫进行网站数据的爬取</p>
<h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p>君子协议，规定了网站中哪些数据刻印被爬取而哪些数据不可被爬取</p>
<h2 id="常用请求头信息"><a href="#常用请求头信息" class="headerlink" title="常用请求头信息"></a>常用请求头信息</h2><ul>
<li>User-Agent：请求载体的身份标识</li>
<li>Connection：请求完毕之后，断开连接还是保持连接</li>
<li>Content-Type：服务器响应回客户端的数据类型</li>
</ul>
<h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><p>基于网络请求的模块，用于模拟浏览器发送请求</p>
<h2 id="使用步骤（requests模块使用）"><a href="#使用步骤（requests模块使用）" class="headerlink" title="使用步骤（requests模块使用）"></a>使用步骤（requests模块使用）</h2><ul>
<li>制定url</li>
<li>发起请求</li>
<li>获取响应数据</li>
<li>持久化存储数据</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>使用arduino远程更新esp8266代码</title>
    <url>/2021/07/25/%E8%BF%9C%E7%A8%8B%E6%9B%B4%E6%96%B0esp8266%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于核心板与开发板不同，每一次烧录要进行步骤相当多。为了懒以及更加简化相关步骤，因此尝试使用OTA进行远程升级代码，此部分仅介绍arduino部分，OTA传输也可通过服务器进行</p>
<span id="more"></span>
<h1 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h1><ul>
<li><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-tips/esp8266-ota/">太极创客的相关示例操作</a><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1>第一次烧录的时候，需要使用tll或者相关方式去进行烧录，之后的话便可以通过网络来进行上传烧录<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2>这里以太极创客的示例代码为例<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project          : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name     : OTA_Flash_Example</span></span><br><span class="line"><span class="comment">团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment">作者/Author              : CYNO朔</span></span><br><span class="line"><span class="comment">日期/Date（YYYYMMDD）     : 20200713</span></span><br><span class="line"><span class="comment">程序目的/Purpose          : </span></span><br><span class="line"><span class="comment">本示例程序用于演示ESP8266的OTA功能。通过本程序，我们将启动ESP8266的OTA程序上传功能。</span></span><br><span class="line"><span class="comment">我们将无需使用连接线将ESP8266与电脑进行连接，而可以使用WiFi对ESP8266上传程序。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">如需了解本程序的详细说明，请参考以下链接：</span></span><br><span class="line"><span class="comment">http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-tips/esp8266-ota/</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">其它说明 / Other Description：</span></span><br><span class="line"><span class="comment">本程序为太极创客团队制作的免费视频教程《零基础入门学用物联网 》中一部分。该教程系统的</span></span><br><span class="line"><span class="comment">向您讲述ESP8266的物联网应用相关的软件和硬件知识。以下是该教程目录页：</span></span><br><span class="line"><span class="comment">http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/                    </span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ArduinoOTA.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Ticker.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 闪烁时间间隔(秒)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> blinkInterval = <span class="number">2</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置wifi接入信息(请根据您的WiFi信息进行修改)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ssid = <span class="string">&quot;taichimaker&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* password = <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line"> </span><br><span class="line">Ticker ticker;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">begin</span>(<span class="number">9600</span>);            </span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">pinMode</span>(<span class="literal">LED_BUILTIN</span>, <span class="literal">OUTPUT</span>);</span><br><span class="line"> </span><br><span class="line">  ticker.<span class="built_in">attach</span>(blinkInterval, tickerCount);  <span class="comment">// 设置Ticker对象</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">connectWifi</span>();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// OTA设置并启动</span></span><br><span class="line">  ArduinoOTA.<span class="built_in">setHostname</span>(<span class="string">&quot;ZHYCarge&quot;</span>);  <span class="comment">//进行OTA名称的设置</span></span><br><span class="line">  ArduinoOTA.<span class="built_in">setPassword</span>(<span class="string">&quot;12345678&quot;</span>); <span class="comment">//设置密码，上传代码的时候会需要</span></span><br><span class="line">  ArduinoOTA.<span class="built_in">begin</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;OTA ready&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ArduinoOTA.<span class="built_in">handle</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在Tinker对象控制下，此函数将会定时执行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tickerCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(<span class="literal">LED_BUILTIN</span>, !<span class="built_in">digitalRead</span>(<span class="literal">LED_BUILTIN</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectWifi</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//开始连接wifi</span></span><br><span class="line">  <span class="built_in">WiFi</span>.<span class="built_in">begin</span>(ssid, password);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//等待WiFi连接,连接成功打印IP</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">WiFi</span>.<span class="built_in">status</span>() != WL_CONNECTED) &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">Serial</span>.<span class="built_in">print</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;WiFi Connected!&quot;</span>);  </span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">print</span>(<span class="string">&quot;IP address:\t&quot;</span>);            </span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="built_in">WiFi</span>.<span class="built_in">localIP</span>());          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将项目编译上传"><a href="#将项目编译上传" class="headerlink" title="将项目编译上传"></a>将项目编译上传</h2>与正常烧录一样，将esp8266连接到设备，选择好相关端口并进行烧录，等待上传完成<br><img src="https://user-images.githubusercontent.com/40520292/126886534-1b6a9ac7-4e0b-4989-ba22-a8e3f9aba6d3.png" alt="image"><br>上传完成之后，esp8266芯片会自动重启，并指示灯会进行闪烁，我们需要手动将esp8266进行重启<br>通过串口监视器，我们发现esp8266已经连接上wifi并且OTA运行正常<br><img src="https://user-images.githubusercontent.com/40520292/126886612-854e0afa-024b-47f2-ab40-88da0cd9183f.png" alt="image"><br>之后我们可以打开端口选择界面，之后我们会发现在串口中多了一个网络串口的位置<br><img src="https://user-images.githubusercontent.com/40520292/126886638-90aa02b7-ee17-4089-986d-90c98ce12502.png" alt="image"><br>点击它之后尝试更改一些信息，例如将OTA的名称更改为<code>ZHYCarge_esp8266</code>并将密码更改为<code>88888888</code>,之后点击上传代码，然后会弹出需要我们输入开发板的密码来进行代码上传<br><img src="https://user-images.githubusercontent.com/40520292/126886745-0dbad5ae-7537-41fb-9d9c-c5977645f597.png" alt="image"><br>之后便会进行代码的上传<br><img src="https://user-images.githubusercontent.com/40520292/126886751-9904e6fa-1e34-43dc-9471-c5f381e10fab.png" alt="image"><br><img src="https://user-images.githubusercontent.com/40520292/126886754-ba57f5c0-575e-464f-aae4-31527fdf9ecd.png" alt="image"><br>之后，我们会发现相关信息已经进行了更改  </li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>可以仅在供电情况下，直接对代码进行上传处理，而不必需要经过相关插拔来实现</li>
<li>简化了上传过程</li>
<li>对于一些无法取下的项目而言，更加有效方便的操作esp8266<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2></li>
<li>如果项目代码过长，可能会导致相关程序卡死，造成不必要的影响</li>
<li>升级代码的时候，需要主机和esp8266连接到同一wifi下，否则可能烧录不成功<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2></li>
<li>由于使用了新的网络串口，因此之前的串口监视器已经失效了，但是我们可以使用putty来登录到开发板中进行查看相关输出  </li>
<li>可以考虑将OTA升级编辑成为一个中断，当中断开启时，便进入OTA升级界面</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>esp8266</tag>
      </tags>
  </entry>
  <entry>
    <title>青岛OJ系统的搭建</title>
    <url>/2021/09/09/%E9%9D%92%E5%B2%9BOJ%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>实验室招新使用，想搭建一个属于实验室专属的OJ界面，方便进行管理以及相关统计。</p>
<p>使用青岛大学的OJ系统进行搭建，<a href="https://github.com/QingdaoU/OnlineJudgeDeploy/">相关github界面</a></p>
<p><strong>请注意：此OJ并<a href="https://github.com/QingdaoU/OnlineJudgeDeploy/issues/70">不支持arm架构</a>，因此需要在arm架构机器上使用的需要自行去寻找其他的OJ界面</strong></p>
<span id="more"></span>

<h1 id="相关资料引用"><a href="#相关资料引用" class="headerlink" title="相关资料引用"></a>相关资料引用</h1><p><a href="https://www.cnblogs.com/stargazerzzh/p/10420049.html">qduoj前端二次开发简略流程</a></p>
<p><a href="https://github.com/QingdaoU/OnlineJudgeDeploy/">OJ官网</a></p>
<p><a href="https://github.com/QingdaoU/OnlineJudgeFE">OJ二次开发官网</a></p>
<h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="先配置基本环境"><a href="#先配置基本环境" class="headerlink" title="先配置基本环境"></a>先配置基本环境</h2><p>1.<code>sudo apt-get update &amp;&amp; sudo apt-get install -y vim python3-pip curl git</code></p>
<p>2.<code>pip3 install --upgrade pip</code></p>
<p>3.<code>pip3 install docker-compose</code></p>
<ul>
<li>第3步的安装与github的官方教程不同，由于该项目需要python3.5以上的支持，而pip仅支持python2.7(至少在我的配置下是这样)，因此安装使用pip3来进行安装</li>
<li>在fish下，<code>&amp;&amp;</code>命令无法被识别，因此需要提前切换到bash来进行安装</li>
</ul>
<h2 id="配置安装docker环境"><a href="#配置安装docker环境" class="headerlink" title="配置安装docker环境"></a>配置安装docker环境</h2><p>使用如下一键安装命令来进行docker的安装</p>
<ul>
<li>在国内环境下：</li>
</ul>
<p><code>sudo curl -sSL https://get.daocloud.io/docker | sh</code></p>
<ul>
<li>在国外环境下：</li>
</ul>
<p><code>sudo curl -sSL get.docker.com | sh</code></p>
<p>如需了解更多，请访问<a href="https://docs.docker.com/install/">Docker官网</a></p>
<h2 id="开始安装OJ系统"><a href="#开始安装OJ系统" class="headerlink" title="开始安装OJ系统"></a>开始安装OJ系统</h2><ol>
<li>选择一个具有合适的空间来进行安装（大概700-800mb）</li>
</ol>
<p>输入如下命令：</p>
<p><code>git clone -b 2.0 https://github.com/QingdaoU/OnlineJudgeDeploy.git &amp;&amp; cd OnlineJudgeDeploy</code></p>
<ol start="2">
<li>输入如下命令去进行自动配置<code>docker-compose up -d</code></li>
</ol>
<p>配置会根据网速来进行协调，大概会在15-30min，之后会自动配置成功</p>
<ul>
<li>请不要占用服务器或者主机的80端口以及443端口，网站会直接占用，否则会启动失败</li>
</ul>
<ol start="3">
<li>在浏览器中输入相关ip便可以直接访问成功</li>
</ol>
<h3 id="如何更改OJ的端口号"><a href="#如何更改OJ的端口号" class="headerlink" title="如何更改OJ的端口号"></a>如何更改OJ的端口号</h3><p>在进行第二步之前，进入到OJ的文件夹中，编辑<code>docker-compose.yml</code>尾部的<code>ports</code>的选项，例如将端口改为90</p>
<p><img src="https://user-images.githubusercontent.com/40520292/132656599-944bbcf8-999a-4507-aa1b-b80950f127e4.png" alt="image"></p>
<h2 id="后期的OJ配置"><a href="#后期的OJ配置" class="headerlink" title="后期的OJ配置"></a>后期的OJ配置</h2><p>因为一上来的OJ环境并不是那么可以让人使用的了，因此需要额外进行一些环境上的配置</p>
<h3 id="基础（这是后期的基础，因此都需要进行配置）"><a href="#基础（这是后期的基础，因此都需要进行配置）" class="headerlink" title="基础（这是后期的基础，因此都需要进行配置）"></a>基础（这是后期的基础，因此都需要进行配置）</h3><p><strong>请注意：安装时也需要配置nodejs的 v8.12.0的安装包，如果没有请自行寻找方式进行安装</strong></p>
<ol>
<li>由于此OJ系统前端都是自动渲染生成的，因此我们需要去Github上下载相关的前端源码</li>
</ol>
<p><code>git clone https://github.com/QingdaoU/OnlineJudgeFE.git</code> </p>
<ol start="2">
<li>安装修改的相关依赖</li>
</ol>
<p>然后我们进入到clone的文件夹中，执行<code>npm install</code></p>
<ol start="3">
<li>之后按照官方的文档进行编辑</li>
</ol>
<p><code>npm run build:dll</code></p>
<ol start="4">
<li>启动本地测试</li>
</ol>
<p><code>npm run dev</code></p>
<ol start="5">
<li>后续修改完成之后进行打包</li>
</ol>
<p><code>npm run build</code></p>
<ol start="6">
<li>让OJ加载修改后的前端文件</li>
</ol>
<p>首先我们需要进入到OJ的那个文件夹下，编辑其<code>docker-compose.yml</code></p>
<p>然后在<code>columes</code>选项中新增加一行，路径请根据实际进行自主修改</p>
<p><img src="https://user-images.githubusercontent.com/40520292/132656615-72b97c7f-d924-4ae2-8823-5a6090487c6f.png" alt="image"></p>
<ol start="7">
<li>之后运行自动配置命令<code>docker-compose up -d</code></li>
</ol>
<ul>
<li>可能在运行之后，会发现界面打不开的现象，那么便重新启动一下OJ系统所对应的docker服务便好</li>
</ul>
<h3 id="将语言更换为中文"><a href="#将语言更换为中文" class="headerlink" title="将语言更换为中文"></a>将语言更换为中文</h3><p>进入前端代码文件夹中，从<code>src/i18n/index.js</code>中修改locale的值为<code>zh-CN</code>，之后直接按照上面的内容打包即可</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
