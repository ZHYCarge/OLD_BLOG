<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZHYCarge的博客</title>
  
  
  <link href="https://zhycarge.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhycarge.github.io/"/>
  <updated>2021-09-13T00:38:05.371Z</updated>
  <id>https://zhycarge.github.io/</id>
  
  <author>
    <name>ZHYCarge</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何实现linux终端代理</title>
    <link href="https://zhycarge.github.io/2021/09/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0linux%E7%9A%84%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86/"/>
    <id>https://zhycarge.github.io/2021/09/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0linux%E7%9A%84%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86/</id>
    <published>2021-09-13T01:00:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于部分终端命令需要从github上进行下载，然而限于国内网速过慢，因此探寻一高方法，可以让终端去使用代理</p><span id="more"></span><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://v2raytech.com/linux-cmd-set-proxy/">Linux终端设置代理</a></p><p><a href="https://www.dailiproxy.com/proxy-vpn/">代理与VPN的区别</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="代理与VPN的区别"><a href="#代理与VPN的区别" class="headerlink" title="代理与VPN的区别"></a>代理与VPN的区别</h2><p>未完待续</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于部分终端命令需要从github上进行下载，然而限于国内网速过慢，因此探寻一高方法，可以让终端去使用代理&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://zhycarge.github.io/categories/linux/"/>
    
    
    <category term="代理" scheme="https://zhycarge.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>apache设置反向代理</title>
    <link href="https://zhycarge.github.io/2021/09/11/apache%E8%AE%BE%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://zhycarge.github.io/2021/09/11/apache%E8%AE%BE%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</id>
    <published>2021-09-11T13:00:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于青岛大学的OJ项目需要占用80端口，并且此服务使用的是docker来进行开展的，因此现阶段并不能找到相关的方式去更换代码，因此采用apache2的自带反代理模式，来实现对域名的映射</p><span id="more"></span>  <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/bluedawn/p/Apache-ReverseProxy.html">Ubuntu Apache2 反代</a></p><p><a href="https://blog.csdn.net/LoveZoeAyo/article/details/120228608">Ubuntu Apache反代(反向代理)设置</a></p><p><a href="https://zhuanlan.zhihu.com/p/230829571">什么是反向代理？</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="什么是反向代理？"><a href="#什么是反向代理？" class="headerlink" title="什么是反向代理？"></a>什么是反向代理？</h2><blockquote><p>反向代理是充当Web服务器网关的代理服务器。当您将请求发送到使用反向代理的Web服务器时，他们将先转到反向代理，由该代理将确定是将其路由到Web服务器还是将其阻止。</p><p>这意味着有了反向代理，您永远不会与使用它的Web服务器进行直接通信。可以将它们看作web服务器或服务器集群的某种包装器。通过负载平衡和缓存，它们可以保护web免遭攻击，并提供更好的web性能。</p></blockquote><h2 id="加载相关模块"><a href="#加载相关模块" class="headerlink" title="加载相关模块"></a>加载相关模块</h2><p>首先我们需要运行apache的模块加载，将下面的几个选项加载上</p><p><code>a2enmod proxy proxy_balancer proxy_http</code></p><p>之后我们需要在apahce的配置服务中设置相关配置</p><ol><li>进入到apache 的配置目录下：</li></ol><p>如我的是<code>etc/apache2/sites-available</code></p><ol start="2"><li>使用你所要配置的域名进行创建一个<code>域名.conf</code>文件</li><li>使用vim或者等相关编辑工具对此conf文件进行编辑</li></ol><p>输入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">ServerName lizi.com:80</span><br><span class="line">ProxyRequests Off</span><br><span class="line">ProxyMaxForwards 100</span><br><span class="line">ProxyPreserveHost On</span><br><span class="line"><span class="comment">#反代理要解析的ip 支持添加端口</span></span><br><span class="line">ProxyPass / http://127.0.0.1:90/</span><br><span class="line">ProxyPassReverse / http://127.0.0.1:90/</span><br><span class="line"></span><br><span class="line">&lt;Proxy *&gt;</span><br><span class="line">Order Deny,Allow</span><br><span class="line">Allow from all</span><br><span class="line">&lt;/Proxy&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：lizi.com是你的域名地址，将其替换输入进去即可</strong></p><ol start="4"><li>在<code>sites-enabled</code>的文件夹下（一般是在<code>etc/apache2</code>目录下）链接一下你刚刚创建的conf文件</li></ol><p><code>ln -s /etc/apahce2/sites-available/域名.conf ../sites-enabled</code></p><ol start="5"><li>之后重启apache服务便可以</li></ol><p><code>systemctl restart apache2</code>或者<code>service apache2 restart</code></p><p>然后访问你的域名，你就会发现已经正常代理到了你所需要的网站上</p><h1 id="相关用途"><a href="#相关用途" class="headerlink" title="相关用途"></a>相关用途</h1><ul><li><strong>该公司可以隐藏其实际内部服务器结构的详细信息</strong>，从而使访问或破坏这些服务器变得更加困难。本质上是黑客保护。</li><li>**反向代理可以使用防火墙设置来帮助防御<a href="https://link.zhihu.com/?target=https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/">DDoS攻击</a>**。该代理可以减轻DDoS的压力并通过合法的流量，而不会损害真实Web服务器的性能。当然，就像一扇人群挤过的门一样，它仍然可能是一个瓶颈，但并不是那种在失败时危及用户数据的瓶颈。</li><li><strong>反向代理可能配备有可加快SSL证书验证速度的硬件</strong>，从而使SSL连接更快且更不容易被利用。</li><li>如果有几台内部Web服务器上有冗余数据，<strong>则反向代理可以充当负载平衡器</strong>，确保每台内部服务器的压力都不大。当每台服务器的功能极小但它们共同构成强大的资源来源时，此功能特别有用。</li><li>通过在请求相同时立即向多个客户端提供动态数据，<strong>可以将反向代理用作动态内容的缓存</strong>。此过程称为网络加速。</li><li><strong>反向代理可以处理</strong> Web服务器的<strong>数据压缩</strong>，以提供更快的连接和较低的主Web服务器压力。</li><li>当访问地址必须保持不变时，<strong>反向代理用于统一网址</strong>。如果您有五个Web服务器，则通常每个服务器都有自己的IP地址。这将使静态脚本难以访问，因为它将被迫访问指</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于青岛大学的OJ项目需要占用80端口，并且此服务使用的是docker来进行开展的，因此现阶段并不能找到相关的方式去更换代码，因此采用apache2的自带反代理模式，来实现对域名的映射&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    
    <category term="笔记" scheme="https://zhycarge.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Apache2" scheme="https://zhycarge.github.io/tags/Apache2/"/>
    
  </entry>
  
  <entry>
    <title>GitHub配置其他域名</title>
    <link href="https://zhycarge.github.io/2021/09/10/GitHub%E9%85%8D%E7%BD%AE%E5%85%B6%E4%BB%96%E5%9F%9F%E5%90%8D/"/>
    <id>https://zhycarge.github.io/2021/09/10/GitHub%E9%85%8D%E7%BD%AE%E5%85%B6%E4%BB%96%E5%9F%9F%E5%90%8D/</id>
    <published>2021-09-10T14:00:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于自己有多余的域名，其次感觉github的域名不太好，因此了解一下如何将自己的域名绑定到GitHub pages上</p><span id="more"></span><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_34392457/article/details/89115236">GitHub Page绑定自己的域名</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>首先为了绑定域名，我们首先需要有一个github的pages的界面，而这个界面往往需要创建的时候是以<code>用户名.github.io</code>进行创建的，创建之后进入到仓库的设置中，将pages服务进行打开</p><p><img src="https://user-images.githubusercontent.com/40520292/132868839-389ee468-6421-46fd-9e21-a9c882da933b.png" alt="image"></p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>我们需要去域名服务商额外分配一个二级域名，这里以阿里云为例：</p><p>创建一个CNAME的域名解析，记录值即为<code>用户名.github.io</code></p><p>然后回到github的pages服务中，找到<code>Custom domain</code>选项，将其中输入框输入你刚刚创建的二级域名，然后稍等片刻，便发现解析成功</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>受限于域名服务商的服务质量，可能你的域名需要十分钟左右的时间来进行解析，因此请保证每一次修改尝试的时候中间隔开了足够的时间，放置由于DNS的问题导致设置出现问题</p><p>如果多次刷新发现还是不行，建议换一个浏览器重新加载，因为浏览器的缓存数据可能对域名进行过保存，但是并未清除掉<br>请注意：如果使用的是GitHub的一键三连，那么需要更新 <code>_config.yml</code> 的相关文件，要不会访问不了<br>本人暂未配置成功，具体原因仍在探索</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于自己有多余的域名，其次感觉github的域名不太好，因此了解一下如何将自己的域名绑定到GitHub pages上&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    
    <category term="笔记" scheme="https://zhycarge.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="GitHub" scheme="https://zhycarge.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>青岛OJ系统的搭建</title>
    <link href="https://zhycarge.github.io/2021/09/09/%E9%9D%92%E5%B2%9BOJ%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://zhycarge.github.io/2021/09/09/%E9%9D%92%E5%B2%9BOJ%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2021-09-09T03:00:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>实验室招新使用，想搭建一个属于实验室专属的OJ界面，方便进行管理以及相关统计。</p><p>使用青岛大学的OJ系统进行搭建，<a href="https://github.com/QingdaoU/OnlineJudgeDeploy/">相关github界面</a></p><p><strong>请注意：此OJ并<a href="https://github.com/QingdaoU/OnlineJudgeDeploy/issues/70">不支持arm架构</a>，因此需要在arm架构机器上使用的需要自行去寻找其他的OJ界面</strong></p><span id="more"></span><h1 id="相关资料引用"><a href="#相关资料引用" class="headerlink" title="相关资料引用"></a>相关资料引用</h1><p><a href="https://www.cnblogs.com/stargazerzzh/p/10420049.html">qduoj前端二次开发简略流程</a></p><p><a href="https://github.com/QingdaoU/OnlineJudgeDeploy/">OJ官网</a></p><p><a href="https://github.com/QingdaoU/OnlineJudgeFE">OJ二次开发官网</a></p><h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="先配置基本环境"><a href="#先配置基本环境" class="headerlink" title="先配置基本环境"></a>先配置基本环境</h2><p>1.<code>sudo apt-get update &amp;&amp; sudo apt-get install -y vim python3-pip curl git</code></p><p>2.<code>pip3 install --upgrade pip</code></p><p>3.<code>pip3 install docker-compose</code></p><ul><li>第3步的安装与github的官方教程不同，由于该项目需要python3.5以上的支持，而pip仅支持python2.7(至少在我的配置下是这样)，因此安装使用pip3来进行安装</li><li>在fish下，<code>&amp;&amp;</code>命令无法被识别，因此需要提前切换到bash来进行安装</li></ul><h2 id="配置安装docker环境"><a href="#配置安装docker环境" class="headerlink" title="配置安装docker环境"></a>配置安装docker环境</h2><p>使用如下一键安装命令来进行docker的安装</p><ul><li>在国内环境下：</li></ul><p><code>sudo curl -sSL https://get.daocloud.io/docker | sh</code></p><ul><li>在国外环境下：</li></ul><p><code>sudo curl -sSL get.docker.com | sh</code></p><p>如需了解更多，请访问<a href="https://docs.docker.com/install/">Docker官网</a></p><h2 id="开始安装OJ系统"><a href="#开始安装OJ系统" class="headerlink" title="开始安装OJ系统"></a>开始安装OJ系统</h2><ol><li>选择一个具有合适的空间来进行安装（大概700-800mb）</li></ol><p>输入如下命令：</p><p><code>git clone -b 2.0 https://github.com/QingdaoU/OnlineJudgeDeploy.git &amp;&amp; cd OnlineJudgeDeploy</code></p><ol start="2"><li>输入如下命令去进行自动配置<code>docker-compose up -d</code></li></ol><p>配置会根据网速来进行协调，大概会在15-30min，之后会自动配置成功</p><ul><li>请不要占用服务器或者主机的80端口以及443端口，网站会直接占用，否则会启动失败</li></ul><ol start="3"><li>在浏览器中输入相关ip便可以直接访问成功</li></ol><h3 id="如何更改OJ的端口号"><a href="#如何更改OJ的端口号" class="headerlink" title="如何更改OJ的端口号"></a>如何更改OJ的端口号</h3><p>在进行第二步之前，进入到OJ的文件夹中，编辑<code>docker-compose.yml</code>尾部的<code>ports</code>的选项，例如将端口改为90</p><p><img src="https://user-images.githubusercontent.com/40520292/132656599-944bbcf8-999a-4507-aa1b-b80950f127e4.png" alt="image"></p><h2 id="后期的OJ配置"><a href="#后期的OJ配置" class="headerlink" title="后期的OJ配置"></a>后期的OJ配置</h2><p>因为一上来的OJ环境并不是那么可以让人使用的了，因此需要额外进行一些环境上的配置</p><h3 id="基础（这是后期的基础，因此都需要进行配置）"><a href="#基础（这是后期的基础，因此都需要进行配置）" class="headerlink" title="基础（这是后期的基础，因此都需要进行配置）"></a>基础（这是后期的基础，因此都需要进行配置）</h3><p><strong>请注意：安装时也需要配置nodejs的 v8.12.0的安装包，如果没有请自行寻找方式进行安装</strong></p><ol><li>由于此OJ系统前端都是自动渲染生成的，因此我们需要去Github上下载相关的前端源码</li></ol><p><code>git clone https://github.com/QingdaoU/OnlineJudgeFE.git</code> </p><ol start="2"><li>安装修改的相关依赖</li></ol><p>然后我们进入到clone的文件夹中，执行<code>npm install</code></p><ol start="3"><li>之后按照官方的文档进行编辑</li></ol><p><code>npm run build:dll</code></p><ol start="4"><li>启动本地测试</li></ol><p><code>npm run dev</code></p><ol start="5"><li>后续修改完成之后进行打包</li></ol><p><code>npm run build</code></p><ol start="6"><li>让OJ加载修改后的前端文件</li></ol><p>首先我们需要进入到OJ的那个文件夹下，编辑其<code>docker-compose.yml</code></p><p>然后在<code>columes</code>选项中新增加一行，路径请根据实际进行自主修改</p><p><img src="https://user-images.githubusercontent.com/40520292/132656615-72b97c7f-d924-4ae2-8823-5a6090487c6f.png" alt="image"></p><ol start="7"><li>之后运行自动配置命令<code>docker-compose up -d</code></li></ol><ul><li>可能在运行之后，会发现界面打不开的现象，那么便重新启动一下OJ系统所对应的docker服务便好</li></ul><h3 id="将语言更换为中文"><a href="#将语言更换为中文" class="headerlink" title="将语言更换为中文"></a>将语言更换为中文</h3><p>进入前端代码文件夹中，从<code>src/i18n/index.js</code>中修改locale的值为<code>zh-CN</code>，之后直接按照上面的内容打包即可</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;实验室招新使用，想搭建一个属于实验室专属的OJ界面，方便进行管理以及相关统计。&lt;/p&gt;
&lt;p&gt;使用青岛大学的OJ系统进行搭建，&lt;a href=&quot;https://github.com/QingdaoU/OnlineJudgeDeploy/&quot;&gt;相关github界面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意：此OJ并&lt;a href=&quot;https://github.com/QingdaoU/OnlineJudgeDeploy/issues/70&quot;&gt;不支持arm架构&lt;/a&gt;，因此需要在arm架构机器上使用的需要自行去寻找其他的OJ界面&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    
    <category term="笔记" scheme="https://zhycarge.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫简介</title>
    <link href="https://zhycarge.github.io/2021/08/22/%E7%88%AC%E8%99%AB%E7%AE%80%E4%BB%8B/"/>
    <id>https://zhycarge.github.io/2021/08/22/%E7%88%AC%E8%99%AB%E7%AE%80%E4%BB%8B/</id>
    <published>2021-08-22T03:00:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>网络爬虫（又称为网页蜘蛛，<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C/143243">网络</a>机器人，在<a href="https://baike.baidu.com/item/FOAF">FOAF</a>社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/13831935">程序</a>或者<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC/1697005">脚本</a>。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。</p><p>​                                                                                    ——百度百科</p></blockquote><span id="more"></span><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="爬虫的相关分类"><a href="#爬虫的相关分类" class="headerlink" title="爬虫的相关分类"></a>爬虫的相关分类</h2><ul><li>通用爬虫</li></ul><p>抓取系统重要的组成部分，抓取的是一整张页面</p><ul><li>聚焦爬虫</li></ul><p>建立在通用爬虫基础之上，抓取页面中特定的局部内容</p><ul><li>增量式爬虫</li></ul><p>检测网站中数据更新的情况，只会抓取网站中最新出来的数据</p><h2 id="反爬机制"><a href="#反爬机制" class="headerlink" title="反爬机制"></a>反爬机制</h2><p>可以制定相关策略或者相关技术手段，可以防止爬虫程鑫进行网站数据的爬取</p><h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p>君子协议，规定了网站中哪些数据刻印被爬取而哪些数据不可被爬取</p><h2 id="常用请求头信息"><a href="#常用请求头信息" class="headerlink" title="常用请求头信息"></a>常用请求头信息</h2><ul><li>User-Agent：请求载体的身份标识</li><li>Connection：请求完毕之后，断开连接还是保持连接</li><li>Content-Type：服务器响应回客户端的数据类型</li></ul><h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><p>基于网络请求的模块，用于模拟浏览器发送请求</p><h2 id="使用步骤（requests模块使用）"><a href="#使用步骤（requests模块使用）" class="headerlink" title="使用步骤（requests模块使用）"></a>使用步骤（requests模块使用）</h2><ul><li>制定url</li><li>发起请求</li><li>获取响应数据</li><li>持久化存储数据</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;网络爬虫（又称为网页蜘蛛，&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C/143243&quot;&gt;网络&lt;/a&gt;机器人，在&lt;a href=&quot;https://baike.baidu.com/item/FOAF&quot;&gt;FOAF&lt;/a&gt;社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的&lt;a href=&quot;https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/13831935&quot;&gt;程序&lt;/a&gt;或者&lt;a href=&quot;https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC/1697005&quot;&gt;脚本&lt;/a&gt;。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。&lt;/p&gt;
&lt;p&gt;​                                                                                    ——百度百科&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="爬虫" scheme="https://zhycarge.github.io/categories/study/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="笔记" scheme="https://zhycarge.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="爬虫" scheme="https://zhycarge.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>图片仿射变换</title>
    <link href="https://zhycarge.github.io/2021/08/18/%E5%9B%BE%E5%83%8F%E7%9A%84%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"/>
    <id>https://zhycarge.github.io/2021/08/18/%E5%9B%BE%E5%83%8F%E7%9A%84%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/</id>
    <published>2021-08-18T03:00:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想跟着b站大佬，去学习一些相关知识</p><p>使用opencv对图像进行仿射变换</p><span id="more"></span><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="什么是仿射变换"><a href="#什么是仿射变换" class="headerlink" title="什么是仿射变换"></a>什么是仿射变换</h2><p>通过将原图片上的三个点经过相关变换去映射到目标图片的三个点的变化，属于线性变换<br>仿射变换保持了二维图像的“平直性”和“平行性”  </p><p>其中：三个点分别为：</p><ul><li>左上角</li><li>左下角</li><li>右下角</li></ul><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;src&quot;</span>, cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;src&#x27;</span>, img)</span><br><span class="line">imgInfo = img.shape</span><br><span class="line">height = imgInfo[<span class="number">0</span>]</span><br><span class="line">weight = imgInfo[<span class="number">1</span>]</span><br><span class="line">matSrc = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, weight-<span class="number">1</span>], [height-<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">matDst = np.float32([[<span class="number">100</span>, <span class="number">100</span>], [<span class="number">300</span>, height], [weight-<span class="number">300</span>, <span class="number">100</span>]])</span><br><span class="line">matAffine = cv2.getAffineTransform(matSrc, matDst)</span><br><span class="line"><span class="comment"># 得到的是一个矩阵的组合</span></span><br><span class="line">dst = cv2.warpAffine(img, matAffine, (weight, height))</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;dst&quot;</span>, cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="原图"><a href="#原图" class="headerlink" title="原图"></a>原图</h3><p><img src="https://user-images.githubusercontent.com/40520292/129829784-50082f62-fa96-4522-8ed2-50e67d11ba08.png" alt="image"></p><h3 id="运行结果图"><a href="#运行结果图" class="headerlink" title="运行结果图"></a>运行结果图</h3><p><img src="https://user-images.githubusercontent.com/40520292/129829800-2cfedcba-ca76-41cb-9563-3aa00d9aa0e7.png" alt="image"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;想跟着b站大佬，去学习一些相关知识&lt;/p&gt;
&lt;p&gt;使用opencv对图像进行仿射变换&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="视觉" scheme="https://zhycarge.github.io/categories/study/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://zhycarge.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="opencv" scheme="https://zhycarge.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>cv实现图片裁剪以及移位</title>
    <link href="https://zhycarge.github.io/2021/07/28/cv%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E4%BB%A5%E5%8F%8A%E7%A7%BB%E4%BD%8D/"/>
    <id>https://zhycarge.github.io/2021/07/28/cv%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E4%BB%A5%E5%8F%8A%E7%A7%BB%E4%BD%8D/</id>
    <published>2021-07-28T06:00:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想跟着b站大佬，去学习一些相关知识</p><p>使用opencv对图像进行裁剪以及移位</p><span id="more"></span><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="图片剪切"><a href="#图片剪切" class="headerlink" title="图片剪切"></a>图片剪切</h2><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片剪切功能</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">imgInfo = img.shape</span><br><span class="line">dst = img[<span class="number">3000</span>:<span class="number">3600</span>, <span class="number">3100</span>:<span class="number">3700</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p>原图：</p><p><img src="https://user-images.githubusercontent.com/40520292/127297201-c871ae9d-7d1d-4fb6-820c-391885d06f04.png" alt="image"></p><p>处理后：</p><p><img src="https://user-images.githubusercontent.com/40520292/127297221-9a843eb7-9783-4c2a-bd33-9a739c03839c.png" alt="image"></p><h2 id="使用API的方式对图片进行位移"><a href="#使用API的方式对图片进行位移" class="headerlink" title="使用API的方式对图片进行位移"></a>使用API的方式对图片进行位移</h2><h3 id="代码部分-1"><a href="#代码部分-1" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># cv2.imshow(&#x27;src&#x27;, img)</span></span><br><span class="line">imgInfo = img.shape</span><br><span class="line">imgH = imgInfo[<span class="number">0</span>]</span><br><span class="line">imgW = imgInfo[<span class="number">1</span>]</span><br><span class="line">matShift = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">200</span>]])</span><br><span class="line">dst = cv2.warpAffine(img, matShift, (imgH, imgW))</span><br><span class="line"><span class="comment"># 参数1：原始图片信息 参数2：移位矩阵 参数3：相关信息</span></span><br><span class="line">cv2.namedWindow(<span class="string">&quot;enhanced&quot;</span>, cv2.WINDOW_FREERATIO)</span><br><span class="line"><span class="comment"># 如果图片特别大，可以采用以上方法</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;enhanced&quot;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>原图：</p><p><img src="https://user-images.githubusercontent.com/40520292/127297242-0cf6465f-54d6-43a4-af48-3908cc0ea422.png" alt="image"></p><p>运行结果：</p><p><img src="https://user-images.githubusercontent.com/40520292/127297265-76b1cf71-2a00-40a4-87d1-7446ea3ffad2.png" alt="image"></p><p>可以看见图像明显的进行了移位</p><h2 id="使用源码的形式对图片进行位移"><a href="#使用源码的形式对图片进行位移" class="headerlink" title="使用源码的形式对图片进行位移"></a>使用源码的形式对图片进行位移</h2><h3 id="代码部分-2"><a href="#代码部分-2" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;YT&quot;</span>, cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;YT&#x27;</span>, img)</span><br><span class="line">imgInfo = img.shape</span><br><span class="line">dst = np.zeros(img.shape, np.uint8)</span><br><span class="line">height = imgInfo[<span class="number">0</span>]</span><br><span class="line">weight = imgInfo[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, height):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, weight-<span class="number">100</span>):</span><br><span class="line">        dst[i][j+<span class="number">100</span>] = img[i, j]</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;img&quot;</span>, cv2.WINDOW_FREERATIO)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://user-images.githubusercontent.com/40520292/127297283-28a10011-e71e-4ace-8965-70d9b053aad5.png" alt="image"></p><p>左边为原图，右边为移动后的图片（由于图片过大，因此放大了一下）</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如果原图太大，当前屏幕无法进行显示"><a href="#如果原图太大，当前屏幕无法进行显示" class="headerlink" title="如果原图太大，当前屏幕无法进行显示"></a>如果原图太大，当前屏幕无法进行显示</h2><p>可以在<code>imshow()</code>方法前面加入<code>cv2.namedWindow(&quot;enhanced&quot;, cv2.WINDOW_FREERATIO)</code>，便可实现窗口自适应并可以进行相关放缩</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;想跟着b站大佬，去学习一些相关知识&lt;/p&gt;
&lt;p&gt;使用opencv对图像进行裁剪以及移位&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="视觉" scheme="https://zhycarge.github.io/categories/study/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://zhycarge.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="opencv" scheme="https://zhycarge.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>从零搭建树莓派</title>
    <link href="https://zhycarge.github.io/2021/07/28/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    <id>https://zhycarge.github.io/2021/07/28/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%A0%91%E8%8E%93%E6%B4%BE/</id>
    <published>2021-07-28T05:40:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章只是记录一下自己从零开始搭建树莓派的辛酸历程，对自己出现以及产生的问题做了个汇总。其中内部有些资源是查到了大佬的解决方法之后懂得了了解的，相关问题的源链接会放在文章底。<br>本篇文章搬运于自己CSDN</p><span id="more"></span><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="树莓派wifi配置（linux系统）"><a href="#树莓派wifi配置（linux系统）" class="headerlink" title="树莓派wifi配置（linux系统）"></a>树莓派wifi配置（linux系统）</h3><p>本方法运用于树莓派没有相关hdmi接口只能使用vnc进行链接的方法<br>将树莓派上的tf卡拔下来，插到电脑上<br>使用管理员权限打开<code>/rootfs/etc/wpa_supplicant</code><br>然后使用文本编辑器打开其中的wpa_supplicant.conf文件（没有的需要自己创建）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">update_config=1</span><br><span class="line">country=CN</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;wifi名称&quot;</span><br><span class="line">psk=&quot;wifi密码&quot;</span><br><span class="line">#自己wifi的加密方式（一般有密码的是下面这个）</span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">&#125;</span><br><span class="line">#如果有其他的可以设置下面的，没有可以删掉</span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=“wifi名称”</span><br><span class="line">        psk=&quot;wifi密码“</span><br><span class="line">        key_mgmt=WPA-PSK</span><br><span class="line">&#125;</span><br><span class="line">#wifi没有密码：</span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=&quot;testing&quot;</span><br><span class="line">    key_mgmt=NONE</span><br><span class="line">&#125;</span><br><span class="line">#你的WIFI是隐藏wifi:</span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=&quot;yourHiddenSSID&quot;</span><br><span class="line">    scan_ssid=1</span><br><span class="line">    psk=&quot;Your_wifi_password&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后保存文件之后将tf卡插入回树莓派启动之后便可以发现你的树莓派连接到wifi了</p><h3 id="树莓派换源"><a href="#树莓派换源" class="headerlink" title="树莓派换源"></a>树莓派换源</h3><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>由于身处国内，所以要从外网get资料并不是那么容易，因此我们需要将树莓派进行换源，达到下载相关软件包的速度快捷。<br>使用命令：<br><code>lsb_release -a</code>    查询自己的树莓派属于哪个版本<br><img src="https://img-blog.csdnimg.cn/20210203094734646.png" alt="版本对应"><br>发现自己版本属于buster版本<br>之后使用以下命令<br><code>sudo nano /etc/apt/source.list</code><br>然后将里面的源进行注释掉，之后找到相关对应版本的国内源（清华啥的），之后进行替换即可。<br>之后运行下面的命令将相关包进行更新<br><code>sudo apt update </code>    从源获取相关的更新包<br><code>sudo apt upgrade</code>    进行更新</p><p>PS：其中nano为文本编辑器，我不知道怎么从外面复制内容到这个编辑器里面，所以一般我直接采用将tf卡直接插到电脑上进行修改（需要电脑系统是linux，windows系统不支持树莓派的系统盘格式）</p><h3 id="会出现的问题"><a href="#会出现的问题" class="headerlink" title="会出现的问题"></a>会出现的问题</h3><p>如果你的源版本与你的树莓派系统版本不对应的话，则会出现依赖错误，导致你后面安装啥也安装不了<br><img src="https://img-blog.csdnimg.cn/20210203095054961.png" alt="血泪史"></p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>孩子只是一个萌新小白，对于自身发现的问题以及相关问题在网上搜了好久也没找到，所以自力更生，防止自己以后忘记，留个备注，如有错误还望多多海涵～</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="linux查询你的wifi名称及密码"><a href="#linux查询你的wifi名称及密码" class="headerlink" title="linux查询你的wifi名称及密码"></a>linux查询你的wifi名称及密码</h3><p>命令如下：<br><code>cd /etc/NetworkManager/system-connections</code><br><code>ls</code><br><code>sudo cat 你想查询的wifi名称</code><br>PS：网上教程，原问题搜不到了，这个方法没查出来过wifi密码，有待改进</p><h2 id="后续更新"><a href="#后续更新" class="headerlink" title="后续更新"></a>后续更新</h2><h3 id="2021-03-05更新"><a href="#2021-03-05更新" class="headerlink" title="2021/03/05更新"></a>2021/03/05更新</h3><p>现在访问使用树莓派更新会面临着更新系统的问题，然后也是官方源，感觉好慢因此<br>终端中输入下面这个命令进入树莓派系统源的地方</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>apt<span class="regexp">/sources.list.d/</span>raspi.list</span><br></pre></td></tr></table></figure><p>将上面的那个注释掉，并且加入下面的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/raspberrypi/</span> buster main ui</span><br></pre></td></tr></table></figure><blockquote><p>注意<br>以上源适用于buster版本的树莓派系统，系统不符可能会造成依赖问题</p></blockquote><h2 id="相关原问题以及解答"><a href="#相关原问题以及解答" class="headerlink" title="相关原问题以及解答"></a>相关原问题以及解答</h2><p>树莓派换源以及依赖问题：<a href="https://blog.csdn.net/fightingboom/article/details/106879019?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-7&spm=1001.2101.3001.4242">点我</a><br>树莓派wifi配置：<a href="https://blog.csdn.net/bona020/article/details/79038914">点我</a><br>有一个讲的比较好的<a href="https://blog.csdn.net/weixin_45985341/article/details/113780422?spm=1001.2014.3001.5501">here</a><br>镜像源推荐<a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/">清华源</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章只是记录一下自己从零开始搭建树莓派的辛酸历程，对自己出现以及产生的问题做了个汇总。其中内部有些资源是查到了大佬的解决方法之后懂得了了解的，相关问题的源链接会放在文章底。&lt;br&gt;本篇文章搬运于自己CSDN&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    
    <category term="树莓派" scheme="https://zhycarge.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>使用opencv对图像进行缩放</title>
    <link href="https://zhycarge.github.io/2021/07/28/%E4%BD%BF%E7%94%A8opencv%E5%AF%B9%E5%9B%BE%E5%83%8F%E8%BF%9B%E8%A1%8C%E7%BC%A9%E6%94%BE/"/>
    <id>https://zhycarge.github.io/2021/07/28/%E4%BD%BF%E7%94%A8opencv%E5%AF%B9%E5%9B%BE%E5%83%8F%E8%BF%9B%E8%A1%8C%E7%BC%A9%E6%94%BE/</id>
    <published>2021-07-28T03:40:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试根据b站大佬的相关视频，扩展自己的知识面以及知识水平</p><span id="more"></span><h1 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h1><p><a href="https://www.bilibili.com/video/BV1QJ411W7SS?p=25">b站视频</a></p><p><a href="https://blog.csdn.net/qq_40317204/article/details/105614120">最近临域插值</a></p><p><a href="https://zhuanlan.zhihu.com/p/110754637">相关介绍</a></p><p><a href="https://www.cnblogs.com/sycy/p/4743620.html">双线性插值</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="现阶段图片缩放类型及相关方法"><a href="#现阶段图片缩放类型及相关方法" class="headerlink" title="现阶段图片缩放类型及相关方法"></a>现阶段图片缩放类型及相关方法</h2><h3 id="最近临域插值"><a href="#最近临域插值" class="headerlink" title="最近临域插值"></a>最近临域插值</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>假设原图像为10x20的图片，而想要将其缩放成为5x10的图片</p><p>使用目标图像的点，去表示原图像的点</p><p>​        （1,2） —&gt;        （2,4）</p><p>如何使用目标图像的点去推断原图像的点</p><p><code>newX = x*(原图像的行/目标图像的行)</code></p><p><code>newY = y*(原图像的列/目标图像的列)</code></p><p>注：如出现小数，需要取整</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>目标各像素点的灰度值代替源图像中与其最邻近像素的灰度值。</p><h4 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><ul><li>算法简单</li><li>相比于其他方法可以更好的去实现</li><li>容易出现色块现象</li><li>会破坏原图像的渐变关系</li></ul><h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="https://user-images.githubusercontent.com/40520292/127262583-c546b29e-f01d-4063-bbf2-a2e90beea45f.png" alt="image"></p><p><code>A1 = 20%上面的点 +80%下面的点</code></p><p><code>B1 = 30%左面的点 +70%右边的点</code></p><p><code>1最终点 = A1*30% + A2*70%</code></p><p> <code>2最终点 = B1*20% + B2*80%</code></p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>双线性插值，又称为双线性内插。在数学上，双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值</p><h4 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><ul><li>内插值法计算量大</li><li>图像质量高，不会出现不连续的现象</li><li>具有低通滤波性质，可能会使得图像在一定程度上变得模糊</li></ul><h2 id="使用双线性插值对图像进行缩放处理"><a href="#使用双线性插值对图像进行缩放处理" class="headerlink" title="使用双线性插值对图像进行缩放处理"></a>使用双线性插值对图像进行缩放处理</h2><h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">imgInfo = img.shape     <span class="comment"># 获取图片信息</span></span><br><span class="line"><span class="built_in">print</span>(imgInfo)</span><br><span class="line">height = imgInfo[<span class="number">0</span>]     <span class="comment"># 图片高度</span></span><br><span class="line">weight = imgInfo[<span class="number">1</span>]     <span class="comment"># 图片宽度</span></span><br><span class="line">mode = imgInfo[<span class="number">2</span>]      <span class="comment"># 图片的组成方式</span></span><br><span class="line"><span class="comment"># 缩放:放大或者缩小     等比例或者非等比例</span></span><br><span class="line">dstHeight = <span class="built_in">int</span>(height*<span class="number">0.5</span>)</span><br><span class="line">dstWeight = <span class="built_in">int</span>(weight*<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片缩放类型： 最近临域插值    双线性插值（默认）   像素关系重采样     立方插值</span></span><br><span class="line">dst = cv2.resize(img, (dstWeight, dstHeight))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(3648, 2736, 3)</span><br></pre></td></tr></table></figure><p>原图：</p><p><img src="https://user-images.githubusercontent.com/40520292/127262602-7abc7bc3-10d8-4410-a75a-223a1e88590f.png" alt="image">  </p><p>运行结果：</p><p><img src="https://user-images.githubusercontent.com/40520292/127262621-e7cc2d88-e168-46e7-aba0-cffd88ed90c6.png" alt="image">  </p><h2 id="最近临域插值法实现照片缩放"><a href="#最近临域插值法实现照片缩放" class="headerlink" title="最近临域插值法实现照片缩放"></a>最近临域插值法实现照片缩放</h2><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>先获取当前图片的信息</li><li>使用numpy创建一个空白模板</li><li>重新加载对应的图片</li></ol><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">效果<span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;YT.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">imgInfo = img.shape</span><br><span class="line">imgHeight = imgInfo[<span class="number">0</span>]</span><br><span class="line">imgWeight = imgInfo[<span class="number">1</span>]</span><br><span class="line">dstHeight = <span class="built_in">int</span>(imgHeight / <span class="number">2</span>)</span><br><span class="line">dstWeight = <span class="built_in">int</span>(imgWeight/<span class="number">2</span>)</span><br><span class="line">dstImg = np.zeros((dstHeight, dstWeight, <span class="number">3</span>), np.uint8)   <span class="comment"># 0-255</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dstHeight):       <span class="comment"># 对应的是行信息</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dstWeight):   <span class="comment"># 对应的是列信息</span></span><br><span class="line">        iNew = <span class="built_in">int</span>(i*(imgHeight*<span class="number">1.0</span>/dstHeight))</span><br><span class="line">        jNew = <span class="built_in">int</span>(j*(imgWeight*<span class="number">1.0</span>/dstWeight))</span><br><span class="line">        dstImg[i, j] = img[iNew, jNew]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dstImg)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p>原图：</p><p><img src="https://user-images.githubusercontent.com/40520292/127262608-6f5eda7e-a080-4c99-9db9-5c33fd90ac6c.png" alt="image">  </p><p>缩放后图片：</p><p><img src="https://user-images.githubusercontent.com/40520292/127262628-e988e823-6060-4d9c-94b2-26a6c13394e9.png" alt="image"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;尝试根据b站大佬的相关视频，扩展自己的知识面以及知识水平&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="视觉" scheme="https://zhycarge.github.io/categories/study/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://zhycarge.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="opencv" scheme="https://zhycarge.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib模块的使用</title>
    <link href="https://zhycarge.github.io/2021/07/27/Matplotlib%E6%A8%A1%E5%9D%97%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/"/>
    <id>https://zhycarge.github.io/2021/07/27/Matplotlib%E6%A8%A1%E5%9D%97%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</id>
    <published>2021-07-27T08:40:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试根据b站大佬来扩充自己的知识面</p><p>使用Matplotlib模块来实现图像的绘制（基础）</p><span id="more"></span><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1QJ411W7SS?p=17">B站视频</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">y = np.array([<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;blue&#x27;</span>)  <span class="comment"># 绘制折线图 [参数1： x轴坐标 参数2： y轴坐标 参数3：颜色]</span></span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;b&#x27;</span>, lw=<span class="number">5</span>)  <span class="comment"># [参数4： 线条宽度]</span></span><br><span class="line"><span class="comment"># 绘图分为折线、 饼状、柱状图</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">y = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">plt.bar(x, y, <span class="number">0.5</span>, alpha=<span class="number">1</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制柱状图[参数1： x轴坐标 参数2：y轴坐标 参数3： 柱状图宽度比例 参数4： 透明度 参数5： 颜色]</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>代码运行结果如下：</p><p><img src="/home/zhycarge/.config/Typora/typora-user-images/image-20210727163647412.png" alt="image-20210727163647412"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="在pycharm中没有看到所显示的图"><a href="#在pycharm中没有看到所显示的图" class="headerlink" title="在pycharm中没有看到所显示的图"></a>在pycharm中没有看到所显示的图</h2><p>在新版pycharm中，图像显示政策进行了修改，在新版界面下，图片显示将出现在<code>Sciview</code>里面，但是我们也可以将其调整出来，调整方法如下：</p><p><kbd> File</kbd>—&gt;<kbd>Settings</kbd>—&gt;<kbd>Tools</kbd>—&gt;<kbd> Python Scientific</kbd></p><p>之后将<code>Show plots in toolwindow</code>勾选的选项关闭即可</p><h2 id="发现没有图像显示"><a href="#发现没有图像显示" class="headerlink" title="发现没有图像显示"></a>发现没有图像显示</h2><p>根据b站视频所敲，但是并没有图像显示，查了一下发现在<code>jupyter</code>中，不使用show方法便可以进行显示，但是在pycharm中，需要使用show方法进行显示</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;尝试根据b站大佬来扩充自己的知识面&lt;/p&gt;
&lt;p&gt;使用Matplotlib模块来实现图像的绘制（基础）&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="视觉" scheme="https://zhycarge.github.io/categories/study/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://zhycarge.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="atplotlib" scheme="https://zhycarge.github.io/tags/atplotlib/"/>
    
  </entry>
  
  <entry>
    <title>使用Numpy模块操作矩阵</title>
    <link href="https://zhycarge.github.io/2021/07/27/Numpy%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhycarge.github.io/2021/07/27/Numpy%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-27T07:40:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试根据b站大佬来扩充自己的知识面</p><p>使用Numpy模块来实现对矩阵的基本运算以及矩阵元素的基本查找</p><span id="more"></span><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1QJ411W7SS?p=17">B站视频</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">data2 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(data1)    <span class="comment"># 打印矩阵内容</span></span><br><span class="line"><span class="built_in">print</span>(data2)    <span class="comment"># 打印矩阵内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data1.shape, data2.shape)  <span class="comment"># 打印矩阵维度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.zeros([<span class="number">2</span>, <span class="number">3</span>]))     <span class="comment"># 打印一个两行三列的空矩阵</span></span><br><span class="line"><span class="built_in">print</span>(np.ones([<span class="number">2</span>, <span class="number">2</span>]))      <span class="comment"># 打印一个两行两列的1矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现矩阵的数据更改</span></span><br><span class="line">data2[<span class="number">1</span>, <span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(data2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现矩阵数据的查找</span></span><br><span class="line"><span class="built_in">print</span>(data2[<span class="number">1</span>, <span class="number">1</span>])  <span class="comment"># 或者是下面这个</span></span><br><span class="line"><span class="built_in">print</span>(data2[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵的基本运算</span></span><br><span class="line">data3 = np.ones([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(data3*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(data3/<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data3+<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data3-<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵的加法乘法</span></span><br><span class="line">data4 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(data3+data4)  <span class="comment"># 对应元素相加</span></span><br><span class="line"><span class="built_in">print</span>(data3 * data4)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3 4 5]</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">(5,) (2, 2)</span><br><span class="line">[[0. 0. 0.]</span><br><span class="line"> [0. 0. 0.]]</span><br><span class="line">[[1. 1.]</span><br><span class="line"> [1. 1.]]</span><br><span class="line">[[1 2]</span><br><span class="line"> [5 4]]</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">[[2. 2. 2.]</span><br><span class="line"> [2. 2. 2.]]</span><br><span class="line">[[0.33333333 0.33333333 0.33333333]</span><br><span class="line"> [0.33333333 0.33333333 0.33333333]]</span><br><span class="line">[[4. 4. 4.]</span><br><span class="line"> [4. 4. 4.]]</span><br><span class="line">[[-2. -2. -2.]</span><br><span class="line"> [-2. -2. -2.]]</span><br><span class="line">[[2. 3. 4.]</span><br><span class="line"> [5. 6. 7.]]</span><br><span class="line">[[1. 2. 3.]</span><br><span class="line"> [4. 5. 6.]]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;尝试根据b站大佬来扩充自己的知识面&lt;/p&gt;
&lt;p&gt;使用Numpy模块来实现对矩阵的基本运算以及矩阵元素的基本查找&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="视觉" scheme="https://zhycarge.github.io/categories/study/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://zhycarge.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="tensorflow" scheme="https://zhycarge.github.io/tags/tensorflow/"/>
    
    <category term="numpy" scheme="https://zhycarge.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>使用tf进行基本的矩阵运算</title>
    <link href="https://zhycarge.github.io/2021/07/26/tf%E8%BF%9B%E8%A1%8C%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/"/>
    <id>https://zhycarge.github.io/2021/07/26/tf%E8%BF%9B%E8%A1%8C%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/</id>
    <published>2021-07-26T08:48:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试根据b站大佬来扩充自己的知识面</p><p>本人使用的环境为tf2.0但是b站视频是1.0，因此与视频会稍有不符合</p><span id="more"></span><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1QJ411W7SS?p=15">B站视频</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="代码片段1"><a href="#代码片段1" class="headerlink" title="代码片段1"></a>代码片段1</h2><p>这里仅贴出跟着b站视频写出来的代码，并在有些区域会有些许注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment"># data1 = tf.placeholder(tf.float32)        # 该方法在2.0版本之后就已经被弃用</span></span><br><span class="line"><span class="comment"># data2 = tf.placeholder(tf.float32)        # 该方法在2.0版本之后就已经被弃用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.0之后使用</span></span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># 初始化新版本的模块化更新信息</span></span><br><span class="line"></span><br><span class="line">data1 = tf.compat.v1.placeholder(tf.float32)</span><br><span class="line">data2 = tf.compat.v1.placeholder(tf.float32)</span><br><span class="line">dataAdd = tf.add(data1, data2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># with tf.sesson() as sess: # 该方法已经在2.0之后弃用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.0之后使用</span></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(dataAdd,  feed_dict=&#123;data1: <span class="number">6</span>, data2: <span class="number">2</span>&#125;))</span><br><span class="line">    <span class="comment"># feed_dict 为其中的内容进行赋值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="代码片段2"><a href="#代码片段2" class="headerlink" title="代码片段2"></a>代码片段2</h2><p>此部分代码表明Python的矩阵维度定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># 初始化新版本的模块化更新信息</span></span><br><span class="line"></span><br><span class="line">data1 = tf.compat.v1.constant([[<span class="number">6</span>, <span class="number">6</span>]])  <span class="comment"># 一行两列</span></span><br><span class="line">data2 = tf.compat.v1.constant([[<span class="number">2</span>], [<span class="number">2</span>]])  <span class="comment"># 两行一列</span></span><br><span class="line">data3 = tf.compat.v1.constant([[<span class="number">3</span>, <span class="number">3</span>]])  <span class="comment"># 一行两列</span></span><br><span class="line">data4 = tf.compat.v1.constant([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])  <span class="comment"># 三行两列</span></span><br><span class="line">data5 = tf.compat.v1.constant([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                               [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                               [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])  <span class="comment"># 三行三列，为了更好区分，因此加了回车</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data5.shape)  <span class="comment"># 打印矩阵维度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(data5))  <span class="comment"># 输出整个矩阵</span></span><br><span class="line">    <span class="built_in">print</span>(sess.run(data5[<span class="number">0</span>]))  <span class="comment"># 输出矩阵的某一行</span></span><br><span class="line">    <span class="built_in">print</span>(sess.run(data5[:, <span class="number">0</span>]))  <span class="comment"># 输出矩阵的某一列</span></span><br><span class="line">    <span class="built_in">print</span>(sess.run(data5[<span class="number">0</span>][<span class="number">0</span>]))  <span class="comment"># 输出矩阵第一行第一列</span></span><br><span class="line"><span class="comment"># 矩阵的起始位置都是0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(3, 3)</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]</span><br><span class="line"> [7 8 9]]</span><br><span class="line">[1 2 3]</span><br><span class="line">[1 4 7]</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>片段</p><h2 id="代码片段3"><a href="#代码片段3" class="headerlink" title="代码片段3"></a>代码片段3</h2><p>此段代码讲解矩阵乘法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵乘法</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;TF_CPP_MIN_LOG_LEVEL&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># 初始化新版本的模块化更新信息</span></span><br><span class="line"></span><br><span class="line">data1 = tf.compat.v1.constant([[<span class="number">6</span>, <span class="number">6</span>]])  <span class="comment"># 一行两列</span></span><br><span class="line">data2 = tf.compat.v1.constant([[<span class="number">2</span>], [<span class="number">2</span>]])  <span class="comment"># 两行一列</span></span><br><span class="line">data3 = tf.compat.v1.constant([[<span class="number">3</span>, <span class="number">3</span>]])  <span class="comment"># 一行两列</span></span><br><span class="line">data4 = tf.compat.v1.constant([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])  <span class="comment"># 三行两列</span></span><br><span class="line">data5 = tf.compat.v1.constant([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                               [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                               [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])  <span class="comment"># 三行三列，为了更好区分，因此加了回车</span></span><br><span class="line">matMul = tf.matmul(data1, data2)</span><br><span class="line">matMul2 = tf.multiply(data1, data2)     <span class="comment"># 类似于加法，对应元素相乘</span></span><br><span class="line">matAdd = tf.add(data1, data3)</span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(matMul))     <span class="comment"># 一维</span></span><br><span class="line">    <span class="built_in">print</span>(sess.run(matAdd))     <span class="comment"># 二维</span></span><br><span class="line">    <span class="built_in">print</span>(sess.run(matMul2))</span><br><span class="line">    <span class="built_in">print</span>(sess.run([matMul, matAdd]))   <span class="comment"># 可以通过中括号，一次性打印多个内容</span></span><br><span class="line"><span class="comment"># MK x KN = MN</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[24]]</span><br><span class="line">[[9 9]]</span><br><span class="line">[[12 12]</span><br><span class="line"> [12 12]]</span><br><span class="line">[array([[24]], dtype=int32), array([[9, 9]], dtype=int32)]</span><br></pre></td></tr></table></figure><h2 id="代码片段4"><a href="#代码片段4" class="headerlink" title="代码片段4"></a>代码片段4</h2><p>如何定义一个基本矩阵</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;TF_CPP_MIN_LOG_LEVEL&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># 初始化新版本的模块化更新信息</span></span><br><span class="line"></span><br><span class="line">mat0 = tf.constant([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])  <span class="comment"># 自己动手，丰衣足食</span></span><br><span class="line">mat1 = tf.zeros([<span class="number">2</span>, <span class="number">3</span>])     <span class="comment"># 定义一个三行两列的空矩阵</span></span><br><span class="line">mat2 = tf.ones([<span class="number">3</span>, <span class="number">2</span>])      <span class="comment"># 定义一个三行两列的1矩阵</span></span><br><span class="line">mat3 = tf.fill([<span class="number">2</span>, <span class="number">3</span>], <span class="number">15</span>)</span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat0))</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat1))</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat2))</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat3))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[0 0 0]</span><br><span class="line"> [0 0 0]]</span><br><span class="line">[[0. 0. 0.]</span><br><span class="line"> [0. 0. 0.]]</span><br><span class="line">[[1. 1.]</span><br><span class="line"> [1. 1.]</span><br><span class="line"> [1. 1.]]</span><br><span class="line">[[15 15 15]</span><br><span class="line"> [15 15 15]]</span><br></pre></td></tr></table></figure><h2 id="代码片段5"><a href="#代码片段5" class="headerlink" title="代码片段5"></a>代码片段5</h2><p>如何定义一个非基本矩阵</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如何定义一个矩阵（非基础）</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;TF_CPP_MIN_LOG_LEVEL&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">tf.compat.v1.disable_eager_execution()  <span class="comment"># 初始化新版本的模块化更新信息</span></span><br><span class="line"></span><br><span class="line">mat1 = tf.constant([[<span class="number">2</span>], [<span class="number">3</span>], [<span class="number">4</span>]])</span><br><span class="line">mat2 = tf.zeros_like(mat1)  <span class="comment"># 定义一个全零矩阵，维度与mat1相同</span></span><br><span class="line">mat3 = tf.linspace(<span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">11</span>)    <span class="comment"># 创建一个从0-2的一个中间具有11个元素的矩阵</span></span><br><span class="line">mat4 = tf.compat.v1.random_uniform([<span class="number">2</span>, <span class="number">3</span>], -<span class="number">1</span>, <span class="number">2</span>)   <span class="comment"># 创建一个2×3的矩阵，并且矩阵数字为 (-1)-2 之间</span></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat2))</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat3))</span><br><span class="line">    <span class="built_in">print</span>(sess.run(mat4))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[0]</span><br><span class="line"> [0]</span><br><span class="line"> [0]]</span><br><span class="line">[0.        0.2       0.4       0.6       0.8       1.        1.2</span><br><span class="line"> 1.4       1.6       1.8000001 2.       ]</span><br><span class="line">[[-0.988165   0.3698578 -0.68531  ]</span><br><span class="line"> [-0.7001637  1.0496833  1.1087246]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="在tf中矩阵的定义"><a href="#在tf中矩阵的定义" class="headerlink" title="在tf中矩阵的定义"></a>在tf中矩阵的定义</h2><p>在python中，定义一个矩阵可以采用以下方法进行定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python中矩阵的定义</span></span><br><span class="line"><span class="comment"># 一行两列:[[6,6]]</span></span><br><span class="line"><span class="comment"># 两行两列:[[6,6],[6,6]]</span></span><br></pre></td></tr></table></figure><h2 id="什么是placeholder"><a href="#什么是placeholder" class="headerlink" title="什么是placeholder"></a>什么是<code>placeholder</code></h2><blockquote><p>Tensorflow中的palceholder，中文翻译为占位符，什么意思呢？</p><p>在Tensoflow2.0以前，还是静态图的设计思想，整个设计理念是计算流图，在编写程序时，首先构筑整个系统的graph，代码并不会直接生效，这一点和python的其他数值计算库（如Numpy等）不同，graph为静态的，在实际的运行时，启动一个session，程序才会真正的运行。这样做的好处就是：避免反复地切换底层程序实际运行的上下文，tensorflow帮你优化整个系统的代码。我们知道，很多python程序的底层为C语言或者其他语言，执行一行脚本，就要切换一次，是有成本的，tensorflow通过计算流图的方式，可以帮你优化整个session需要执行的代码。</p><p>在代码层面，每一个tensor值在graph上都是一个op，当我们将train数据分成一个个minibatch然后传入网络进行训练时，每一个minibatch都将是一个op，这样的话，一副graph上的op未免太多，也会产生巨大的开销；于是就有了tf.placeholder()，我们每次可以将 一个minibatch传入到x = tf.placeholder(tf.float32,[None,32])上，下一次传入的x都替换掉上一次传入的x，这样就对于所有传入的minibatch x就只会产生一个op，不会产生其他多余的op，进而减少了graph的开销。<br>——<a href="https://blog.csdn.net/caoyuan666/article/details/104706756">CSDN</a></p></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h2><h4 id="报错信息为AttributeError-module-39-tensorflow-39-has-no-attribute-39-placeholder-39"><a href="#报错信息为AttributeError-module-39-tensorflow-39-has-no-attribute-39-placeholder-39" class="headerlink" title="报错信息为AttributeError: module &#39;tensorflow&#39; has no attribute &#39;placeholder&#39;"></a>报错信息为<code>AttributeError: module &#39;tensorflow&#39; has no attribute &#39;placeholder&#39;</code></h4><p>由于本人使用的环境不同，根据<a href="https://blog.csdn.net/caoyuan666/article/details/104706756">CSDN</a>上的信息而言，表明在tf版本2.0之后，该方法就已经被进行了弃用，因此我们需要寻找到2.0版本的对应方法，对应方法已经在相关代码片段中进行提及</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;尝试根据b站大佬来扩充自己的知识面&lt;/p&gt;
&lt;p&gt;本人使用的环境为tf2.0但是b站视频是1.0，因此与视频会稍有不符合&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="视觉" scheme="https://zhycarge.github.io/categories/study/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://zhycarge.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="tensorflow" scheme="https://zhycarge.github.io/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>使用arduino远程更新esp8266代码</title>
    <link href="https://zhycarge.github.io/2021/07/25/%E8%BF%9C%E7%A8%8B%E6%9B%B4%E6%96%B0esp8266%E4%BB%A3%E7%A0%81/"/>
    <id>https://zhycarge.github.io/2021/07/25/%E8%BF%9C%E7%A8%8B%E6%9B%B4%E6%96%B0esp8266%E4%BB%A3%E7%A0%81/</id>
    <published>2021-07-25T02:50:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于核心板与开发板不同，每一次烧录要进行步骤相当多。为了懒以及更加简化相关步骤，因此尝试使用OTA进行远程升级代码，此部分仅介绍arduino部分，OTA传输也可通过服务器进行</p><span id="more"></span><h1 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h1><ul><li><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-tips/esp8266-ota/">太极创客的相关示例操作</a><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1>第一次烧录的时候，需要使用tll或者相关方式去进行烧录，之后的话便可以通过网络来进行上传烧录<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2>这里以太极创客的示例代码为例<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project          : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name     : OTA_Flash_Example</span></span><br><span class="line"><span class="comment">团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment">作者/Author              : CYNO朔</span></span><br><span class="line"><span class="comment">日期/Date（YYYYMMDD）     : 20200713</span></span><br><span class="line"><span class="comment">程序目的/Purpose          : </span></span><br><span class="line"><span class="comment">本示例程序用于演示ESP8266的OTA功能。通过本程序，我们将启动ESP8266的OTA程序上传功能。</span></span><br><span class="line"><span class="comment">我们将无需使用连接线将ESP8266与电脑进行连接，而可以使用WiFi对ESP8266上传程序。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">如需了解本程序的详细说明，请参考以下链接：</span></span><br><span class="line"><span class="comment">http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-tips/esp8266-ota/</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">其它说明 / Other Description：</span></span><br><span class="line"><span class="comment">本程序为太极创客团队制作的免费视频教程《零基础入门学用物联网 》中一部分。该教程系统的</span></span><br><span class="line"><span class="comment">向您讲述ESP8266的物联网应用相关的软件和硬件知识。以下是该教程目录页：</span></span><br><span class="line"><span class="comment">http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/                    </span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ArduinoOTA.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Ticker.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 闪烁时间间隔(秒)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> blinkInterval = <span class="number">2</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置wifi接入信息(请根据您的WiFi信息进行修改)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ssid = <span class="string">&quot;taichimaker&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* password = <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line"> </span><br><span class="line">Ticker ticker;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">begin</span>(<span class="number">9600</span>);            </span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">pinMode</span>(<span class="literal">LED_BUILTIN</span>, <span class="literal">OUTPUT</span>);</span><br><span class="line"> </span><br><span class="line">  ticker.<span class="built_in">attach</span>(blinkInterval, tickerCount);  <span class="comment">// 设置Ticker对象</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">connectWifi</span>();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// OTA设置并启动</span></span><br><span class="line">  ArduinoOTA.<span class="built_in">setHostname</span>(<span class="string">&quot;ZHYCarge&quot;</span>);  <span class="comment">//进行OTA名称的设置</span></span><br><span class="line">  ArduinoOTA.<span class="built_in">setPassword</span>(<span class="string">&quot;12345678&quot;</span>); <span class="comment">//设置密码，上传代码的时候会需要</span></span><br><span class="line">  ArduinoOTA.<span class="built_in">begin</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;OTA ready&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ArduinoOTA.<span class="built_in">handle</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在Tinker对象控制下，此函数将会定时执行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tickerCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(<span class="literal">LED_BUILTIN</span>, !<span class="built_in">digitalRead</span>(<span class="literal">LED_BUILTIN</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectWifi</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//开始连接wifi</span></span><br><span class="line">  <span class="built_in">WiFi</span>.<span class="built_in">begin</span>(ssid, password);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//等待WiFi连接,连接成功打印IP</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">WiFi</span>.<span class="built_in">status</span>() != WL_CONNECTED) &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">Serial</span>.<span class="built_in">print</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;WiFi Connected!&quot;</span>);  </span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">print</span>(<span class="string">&quot;IP address:\t&quot;</span>);            </span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="built_in">WiFi</span>.<span class="built_in">localIP</span>());          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将项目编译上传"><a href="#将项目编译上传" class="headerlink" title="将项目编译上传"></a>将项目编译上传</h2>与正常烧录一样，将esp8266连接到设备，选择好相关端口并进行烧录，等待上传完成<br><img src="https://user-images.githubusercontent.com/40520292/126886534-1b6a9ac7-4e0b-4989-ba22-a8e3f9aba6d3.png" alt="image"><br>上传完成之后，esp8266芯片会自动重启，并指示灯会进行闪烁，我们需要手动将esp8266进行重启<br>通过串口监视器，我们发现esp8266已经连接上wifi并且OTA运行正常<br><img src="https://user-images.githubusercontent.com/40520292/126886612-854e0afa-024b-47f2-ab40-88da0cd9183f.png" alt="image"><br>之后我们可以打开端口选择界面，之后我们会发现在串口中多了一个网络串口的位置<br><img src="https://user-images.githubusercontent.com/40520292/126886638-90aa02b7-ee17-4089-986d-90c98ce12502.png" alt="image"><br>点击它之后尝试更改一些信息，例如将OTA的名称更改为<code>ZHYCarge_esp8266</code>并将密码更改为<code>88888888</code>,之后点击上传代码，然后会弹出需要我们输入开发板的密码来进行代码上传<br><img src="https://user-images.githubusercontent.com/40520292/126886745-0dbad5ae-7537-41fb-9d9c-c5977645f597.png" alt="image"><br>之后便会进行代码的上传<br><img src="https://user-images.githubusercontent.com/40520292/126886751-9904e6fa-1e34-43dc-9471-c5f381e10fab.png" alt="image"><br><img src="https://user-images.githubusercontent.com/40520292/126886754-ba57f5c0-575e-464f-aae4-31527fdf9ecd.png" alt="image"><br>之后，我们会发现相关信息已经进行了更改  </li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可以仅在供电情况下，直接对代码进行上传处理，而不必需要经过相关插拔来实现</li><li>简化了上传过程</li><li>对于一些无法取下的项目而言，更加有效方便的操作esp8266<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2></li><li>如果项目代码过长，可能会导致相关程序卡死，造成不必要的影响</li><li>升级代码的时候，需要主机和esp8266连接到同一wifi下，否则可能烧录不成功<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2></li><li>由于使用了新的网络串口，因此之前的串口监视器已经失效了，但是我们可以使用putty来登录到开发板中进行查看相关输出  </li><li>可以考虑将OTA升级编辑成为一个中断，当中断开启时，便进入OTA升级界面</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于核心板与开发板不同，每一次烧录要进行步骤相当多。为了懒以及更加简化相关步骤，因此尝试使用OTA进行远程升级代码，此部分仅介绍arduino部分，OTA传输也可通过服务器进行&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="硬件" scheme="https://zhycarge.github.io/categories/study/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="esp8266" scheme="https://zhycarge.github.io/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>如何简单的安装arduino以及esp8266相关库</title>
    <link href="https://zhycarge.github.io/2021/07/21/%E5%A6%82%E4%BD%95%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%89%E8%A3%85arduino%E4%BB%A5%E5%8F%8Aesp8266%E7%9B%B8%E5%85%B3%E5%BA%93/"/>
    <id>https://zhycarge.github.io/2021/07/21/%E5%A6%82%E4%BD%95%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%89%E8%A3%85arduino%E4%BB%A5%E5%8F%8Aesp8266%E7%9B%B8%E5%85%B3%E5%BA%93/</id>
    <published>2021-07-21T12:50:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这就是一个很简单的安装教程，相信我，很简单。。。</p><span id="more"></span><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul><li>首先<a href="https://www.jianshu.com/p/0bc77e7078e2">安装arduino</a>【安装教程参考部分便好】</li><li>其次需要<a href="https://zhycarge.github.io/2021/07/14/esp8266%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#more">安装esp8266相关库</a>  </li><li>如果正常流程安装不了库文件，可以采用我们库进行安装，<a href="https://zhycarge.github.io/2021/07/16/arduino%E5%AE%89%E8%A3%85%E5%BA%93/">点我查看</a></li><li>之后我们需要<a href="https://zhycarge.github.io/2021/07/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8esp8266/#more">尝试编译一次代码</a>【只需要检查相关库是否存在，不需要烧录到芯片】<h1 id="相关资料参考"><a href="#相关资料参考" class="headerlink" title="相关资料参考"></a>相关资料参考</h1><img src="https://user-images.githubusercontent.com/40520292/126493721-63adff26-bfb1-46ff-8530-5d811b197a9b.png" alt="image"></li></ul><p>【arduino安装包位置】  </p><p><img src="https://user-images.githubusercontent.com/40520292/126493844-f6e941db-8bde-4446-b138-1acc9c04b07f.png" alt="image"><br>【esp8266相关库文件位置】</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这就是一个很简单的安装教程，相信我，很简单。。。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="硬件" scheme="https://zhycarge.github.io/categories/study/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="esp8266" scheme="https://zhycarge.github.io/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>esp8266(贴片)使用ttl烧录程序</title>
    <link href="https://zhycarge.github.io/2021/07/18/esp8266(%E8%B4%B4%E7%89%87)%E4%BD%BF%E7%94%A8ttl%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F/"/>
    <id>https://zhycarge.github.io/2021/07/18/esp8266(%E8%B4%B4%E7%89%87)%E4%BD%BF%E7%94%A8ttl%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-07-18T12:40:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于实验室以及小学期培训所用到的芯片是贴片芯片，并没有mirco usb来进行编写烧录，需要在烧录前做一些准备，因此出一篇博客，顺便学习一下esp8266（贴片）的相关信息</p><span id="more"></span><h1 id="相关参考资料"><a href="#相关参考资料" class="headerlink" title="相关参考资料"></a>相关参考资料</h1><p><a href="https://blog.csdn.net/qq_36958104/article/details/103406214?spm=1001.2014.3001.5506">ESP8266下载AT固件</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="看引脚图"><a href="#看引脚图" class="headerlink" title="看引脚图"></a>看引脚图</h2><p>首先需要查看一下esp8266（贴片）的引脚图，根据引脚图功能，以及网上的相关参考文件，对线路进行焊接<br><img src="https://user-images.githubusercontent.com/40520292/126067535-a7e74406-c8bf-4c50-8235-9b5288c6df91.png" alt="引脚图"><br>【图源必应】</p><h2 id="查询相关资料"><a href="#查询相关资料" class="headerlink" title="查询相关资料"></a>查询相关资料</h2><p>ESP8266的相关引脚</p><table><thead><tr><th align="center">序号</th><th align="center">引脚标号</th><th align="center">引脚作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">GND</td><td align="center">地</td><td align="center">接电源负极或者io口置零使用</td></tr><tr><td align="center">2</td><td align="center">VCC</td><td align="center">电源正极</td><td align="center">一般为3.3V，外部供电使用</td></tr><tr><td align="center">3</td><td align="center">RST</td><td align="center">复位</td><td align="center">外部复位引脚，低电平复位</td></tr><tr><td align="center">4</td><td align="center">RXD</td><td align="center">数据接收端</td><td align="center">用于数据传输</td></tr><tr><td align="center">5</td><td align="center">TXD</td><td align="center">数据发送端</td><td align="center">用于数据传输</td></tr><tr><td align="center">6</td><td align="center">GPIO0</td><td align="center">工作模式选择</td><td align="center">当高电平为工作模式；当为低电平为下载模式</td></tr><tr><td align="center">7</td><td align="center">GPIO15</td><td align="center">SS (SPI)</td><td align="center">运行以及编译时保持低电平</td></tr></tbody></table><p>在运行过程种，我们只需要对vcc以及gnd进行接线便可以使用，并不需要外接其他IO口<br>因此我们在烧录程序之前先要对手上的芯片进行接线<br><strong>请注意：esp8266（贴片并无内置上拉电阻，因此为确保安全，请在危险操作时接入上拉电阻）</strong></p><h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><p><img src="https://user-images.githubusercontent.com/40520292/126068460-ff83639f-f107-4c2a-9384-0bbd9cff5ce2.jpg" alt="1626614185608"><br>接线前</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于实验室以及小学期培训所用到的芯片是贴片芯片，并没有mirco usb来进行编写烧录，需要在烧录前做一些准备，因此出一篇博客，顺便学习一下esp8266（贴片）的相关信息&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="硬件" scheme="https://zhycarge.github.io/categories/study/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="esp8266" scheme="https://zhycarge.github.io/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>使用github action对gitee进行同步</title>
    <link href="https://zhycarge.github.io/2021/07/18/%E4%BD%BF%E7%94%A8github%20action%E5%AF%B9gitee%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5/"/>
    <id>https://zhycarge.github.io/2021/07/18/%E4%BD%BF%E7%94%A8github%20action%E5%AF%B9gitee%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5/</id>
    <published>2021-07-18T12:08:00.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近发现github action可以做好多的事情，尝试使用这个东西来将自己的两个仓库内容进行同步  </p><span id="more"></span><p>即使可以在本地的配置文件，将仓库同时关注到本地仓库上，但是如果更换仓库或者更换设备之后，就得重新配置，这不够懒，因此不符合我的想法，因此制作一个文章来记录一下相关操作  </p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/ssgeek/p/15009012.html">使用github action实现github到gitee的代码同步</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><strong>先鸽着，等我下次换到linux上在写</strong>，如有急用可以看上面的，大概看了一下，问题不大</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近发现github action可以做好多的事情，尝试使用这个东西来将自己的两个仓库内容进行同步  &lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    
    <category term="github action" scheme="https://zhycarge.github.io/tags/github-action/"/>
    
  </entry>
  
  <entry>
    <title>arduino安装库(线下)</title>
    <link href="https://zhycarge.github.io/2021/07/16/arduino%E5%AE%89%E8%A3%85%E5%BA%93/"/>
    <id>https://zhycarge.github.io/2021/07/16/arduino%E5%AE%89%E8%A3%85%E5%BA%93/</id>
    <published>2021-07-16T05:25:36.000Z</published>
    <updated>2021-09-13T00:38:05.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于部分库的获得需要通过国外网站，而对于培训来讲，让每个人翻墙不太好，因此出此文章</p><span id="more"></span><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="下载所需库"><a href="#下载所需库" class="headerlink" title="下载所需库"></a>下载所需库</h2><p>通过任意渠道去获取到你所需要的库，包括但不限于直接上github上下载、找学长学姐要、网盘里有提供，总之下载下来解压好便可以</p><h2 id="安装所需库"><a href="#安装所需库" class="headerlink" title="安装所需库"></a>安装所需库</h2><p>将所下载好的安装包解压，我们会得到如下文件夹</p><p><img src="https://user-images.githubusercontent.com/40520292/125896645-9864ac96-53a4-4528-9949-56f279f57815.png" alt="image"></p><p>之后将这些文件夹统一放置在arduinio安装的目录下的libries，比如我的是<code>F:\arduino\libraries</code>：</p><p><img src="https://user-images.githubusercontent.com/40520292/125896875-70755954-cdc7-4877-9c3f-ba936e9b8a64.png" alt="image"></p><p>之后重启arduino便可以</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>打开arduino，看看是不是会多出来这些库呢？</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于部分库的获得需要通过国外网站，而对于培训来讲，让每个人翻墙不太好，因此出此文章&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="硬件" scheme="https://zhycarge.github.io/categories/study/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="esp8266" scheme="https://zhycarge.github.io/tags/esp8266/"/>
    
    <category term="arduino" scheme="https://zhycarge.github.io/tags/arduino/"/>
    
  </entry>
  
  <entry>
    <title>如何使用esp8266</title>
    <link href="https://zhycarge.github.io/2021/07/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8esp8266/"/>
    <id>https://zhycarge.github.io/2021/07/14/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8esp8266/</id>
    <published>2021-07-14T12:45:00.000Z</published>
    <updated>2021-07-15T08:42:04.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>安装完成之后，就开始编写程序了，如51点亮第一个流水灯为例，本次尝试使用esp8266的相关模块，让其创建一个局域网</p><span id="more"></span><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>以太极创客的实例代码为例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU接入点模式</span></span><br><span class="line"><span class="comment">By 太极创客（http://www.taichi-maker.com）</span></span><br><span class="line"><span class="comment">2019-03-11</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">此程序用于演示如何将NodeMCU以接入点模式工作。通过此程序，您可以使用</span></span><br><span class="line"><span class="comment">电脑或者手机连接NodeMCU所建立WiFi网络。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">网络名: taichi-maker</span></span><br><span class="line"><span class="comment">密码：12345678</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">如需获得更多关于如何使用NodeMCU开发物联网的教程和资料信息</span></span><br><span class="line"><span class="comment">请参考太极创客网站（http://www.taichi-maker.com）</span></span><br><span class="line"><span class="comment">并在首页搜索栏中搜索关键字：物联网</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ssid = <span class="string">&quot;taichi-maker&quot;</span>; <span class="comment">// 这里定义将要建立的WiFi名称。此处以&quot;taichi-maker&quot;为示例</span></span><br><span class="line">                                   <span class="comment">// 您可以将自己想要建立的WiFi名称填写入此处的双引号中</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *password = <span class="string">&quot;12345678&quot;</span>;  <span class="comment">// 这里定义将要建立的WiFi密码。此处以12345678为示例</span></span><br><span class="line">                                    <span class="comment">// 您可以将自己想要使用的WiFi密码放入引号内</span></span><br><span class="line">                                    <span class="comment">// 如果建立的WiFi不要密码，则在双引号内不要填入任何信息</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);              <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  WiFi.softAP(ssid, password);     <span class="comment">// 此语句是重点。WiFi.softAP用于启动NodeMCU的AP模式。</span></span><br><span class="line">                                   <span class="comment">// 括号中有两个参数，ssid是WiFi名。password是WiFi密码。</span></span><br><span class="line">                                   <span class="comment">// 这两个参数具体内容在setup函数之前的位置进行定义。</span></span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  Serial.print(<span class="string">&quot;Access Point: &quot;</span>);    <span class="comment">// 通过串口监视器输出信息</span></span><br><span class="line">  Serial.println(ssid);              <span class="comment">// 告知用户NodeMCU所建立的WiFi名</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address: &quot;</span>);      <span class="comment">// 以及NodeMCU的IP地址</span></span><br><span class="line">  Serial.println(WiFi.softAPIP());   <span class="comment">// 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安装相关库"><a href="#安装相关库" class="headerlink" title="安装相关库"></a>安装相关库</h2><p>进行编译的话我们需要安装支持相关编程的库文件：点击<kbd>工具</kbd>—&gt;<kbd>管理库</kbd>—&gt;搜索<code>esp8266wifi</code>—&gt;点击安装便可以</p><p><img src="/images/pasted-18.png" alt="upload successful"></p><p><img src="/images/pasted-19.png" alt="upload successful"></p><p><img src="/images/pasted-21.png" alt="upload successful"></p><p>之后我们需要选择芯片的指定型号，由于我使用的是<code>ESP-12F</code>的芯片，因此选择</p><p><img src="/images/pasted-24.png" alt="upload successful"></p><h2 id="将esp8266接入你的电脑"><a href="#将esp8266接入你的电脑" class="headerlink" title="将esp8266接入你的电脑"></a>将esp8266接入你的电脑</h2><p>与51芯片不同，接入芯片只需要一根能传输数据的<code>miro-usb</code>便可以进行实现，因此只需要找一个线将它与你电脑相连便可以了</p><h2 id="选择正确的端口号"><a href="#选择正确的端口号" class="headerlink" title="选择正确的端口号"></a>选择正确的端口号</h2><p>由于硬件需要选择端口来对硬件进行烧录，查找端口号的操作步骤为:右键<kbd>此电脑</kbd>—&gt;<kbd>管理</kbd>—&gt;<kbd>设备管理器</kbd>—&gt;<kbd>端口(COM和LPT)</kbd>，查找有无CH340接口，并确定它所对应的端口号</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>当代码一切正常的时候，你会在控制台得到一串信息，同时，再wifi处可以发现一个热点</p><p><img src="/images/pasted-25.png" alt="upload successful"></p><p><img src="/images/pasted-26.png" alt="upload successful"></p><p><img src="/images/pasted-27.png" alt="upload successful"></p><h1 id="产生错误"><a href="#产生错误" class="headerlink" title="产生错误"></a>产生错误</h1><h2 id="显示找不到库"><a href="#显示找不到库" class="headerlink" title="显示找不到库"></a>显示找不到库</h2><p><img src="/images/pasted-17.png" alt="upload successful"></p><p>尝试顺便安装下面的这两个库文件</p><p><img src="/images/pasted-22.png" alt="upload successful"></p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p>如果还出现了错误，不妨检查一下，有没有选择正确的开发板。。。</p><h2 id="发现什么都没有输出"><a href="#发现什么都没有输出" class="headerlink" title="发现什么都没有输出"></a>发现什么都没有输出</h2><p>有可能是版本问题，其次上文代码只会再连接成功的时候输出一遍，因此有些高版本可能不允许一边打开串口监视器一边上传代码，因此导致代码运行时并未启动监控<br><strong>建议：<code>按esp8266的Rst键</code></strong></p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>硬件的开发总是与软件有着些许不同，也许你的程序再今天可以跑起来，但是不代表明天甚至下一刻可以使用，也许，这就是硬件的奥秘吧</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;安装完成之后，就开始编写程序了，如51点亮第一个流水灯为例，本次尝试使用esp8266的相关模块，让其创建一个局域网&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="硬件" scheme="https://zhycarge.github.io/categories/study/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="esp8266" scheme="https://zhycarge.github.io/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 后台运行</title>
    <link href="https://zhycarge.github.io/2021/07/14/Hexo-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    <id>https://zhycarge.github.io/2021/07/14/Hexo-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</id>
    <published>2021-07-14T08:24:00.000Z</published>
    <updated>2021-07-15T08:42:04.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于需要hexo-damin支持编写博客，所以需要将hexo服务进行一直开启，但是由于ssh有相关连接限制，又不想修改ssh配置文件，所以出此博客</p><span id="more"></span><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="安装pm2模块"><a href="#安装pm2模块" class="headerlink" title="安装pm2模块"></a>安装pm2模块</h2><h3 id="什么是pm2模块"><a href="#什么是pm2模块" class="headerlink" title="什么是pm2模块"></a>什么是pm2模块</h3><p>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。 下面就对PM2进行入门性的介绍，基本涵盖了PM2的常用的功能和配置。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>输入指令<br><code> npm  install -g pm2</code>来进行安装</p><h2 id="在博客根目录下创建run-js文件"><a href="#在博客根目录下创建run-js文件" class="headerlink" title="在博客根目录下创建run.js文件"></a>在博客根目录下创建<code>run.js</code>文件</h2><p>在博客根目录下创建一个<code>run.js</code>的文件，并在里面输入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//将hexo保持后台运行</span><br><span class="line">const &#123; <span class="built_in">exec</span> &#125; = require(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;hexo server&#x27;</span>,(error, stdout, stderr) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(error)&#123;</span><br><span class="line">                console.log(<span class="string">&#x27;exec error: $&#123;error&#125;&#x27;</span>)</span><br><span class="line">                <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        console.log(<span class="string">&#x27;stdout: $&#123;stdout&#125;&#x27;</span>);</span><br><span class="line">        console.log(<span class="string">&#x27;stderr: $&#123;stderr&#125;&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="之后在根目录下运行"><a href="#之后在根目录下运行" class="headerlink" title="之后在根目录下运行"></a>之后在根目录下运行</h2><p>输入：<code>pm2 start run.js </code></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如何关停pm2"><a href="#如何关停pm2" class="headerlink" title="如何关停pm2"></a>如何关停pm2</h2><p>输入<code>pm2 stop all</code>来关停所有的pm2运行项目</p><h2 id="pm2相关命令汇总"><a href="#pm2相关命令汇总" class="headerlink" title="pm2相关命令汇总"></a>pm2相关命令汇总</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pm2 <span class="literal">start</span> app.js <span class="comment"># 启动app.js应用程序</span></span><br><span class="line"> pm2 <span class="literal">start</span> app.js -i <span class="number">4</span> <span class="comment"># cluster mode 模式启动4个app.js的应用实例</span></span><br><span class="line"><span class="comment"># 4个应用程序会自动进行负载均衡</span></span><br><span class="line"> pm2 <span class="literal">start</span> app.js --<span class="attr">name=</span><span class="string">&quot;api&quot;</span> <span class="comment"># 启动应用程序并命名为 &quot;api&quot;</span></span><br><span class="line"> pm2 <span class="literal">start</span> app.js --watch <span class="comment"># 当文件变化时自动重启应用</span></span><br><span class="line"> pm2 <span class="literal">start</span> script.sh <span class="comment"># 启动 bash 脚本</span></span><br><span class="line"></span><br><span class="line"> pm2 list <span class="comment"># 列表 PM2 启动的所有的应用程序</span></span><br><span class="line"> pm2 monit <span class="comment"># 显示每个应用程序的CPU和内存占用情况</span></span><br><span class="line"> pm2 show [app-name] <span class="comment"># 显示应用程序的所有信息</span></span><br><span class="line"></span><br><span class="line"> pm2 logs <span class="comment"># 显示所有应用程序的日志</span></span><br><span class="line"> pm2 logs [app-name] <span class="comment"># 显示指定应用程序的日志</span></span><br><span class="line">pm2 flush</span><br><span class="line"></span><br><span class="line"> pm2 <span class="literal">stop</span> all <span class="comment"># 停止所有的应用程序</span></span><br><span class="line"> pm2 <span class="literal">stop</span> <span class="number">0</span> <span class="comment"># 停止 id为 0的指定应用程序</span></span><br><span class="line"> pm2 restart all <span class="comment"># 重启所有应用</span></span><br><span class="line"> pm2 reload all <span class="comment"># 重启 cluster mode下的所有应用</span></span><br><span class="line"> pm2 gracefulReload all <span class="comment"># Graceful reload all apps in cluster mode</span></span><br><span class="line"> pm2 delete all <span class="comment"># 关闭并删除所有应用</span></span><br><span class="line">pm2 delete <span class="number">0</span> <span class="comment"># 删除指定应用 id 0</span></span><br><span class="line"> pm2 scale api <span class="number">10</span> <span class="comment"># 把名字叫api的应用扩展到10个实例</span></span><br><span class="line"> pm2 reset [app-name] <span class="comment"># 重置重启数量</span></span><br><span class="line"></span><br><span class="line"> pm2 startup <span class="comment"># 创建开机自启动命令</span></span><br><span class="line"> pm2 save <span class="comment"># 保存当前应用列表</span></span><br><span class="line"> pm2 resurrect <span class="comment"># 重新加载保存的应用列表</span></span><br><span class="line"> pm2 update <span class="comment"># Save processes, kill PM2 and restore processes</span></span><br><span class="line"> pm2 generate <span class="comment"># Generate a sample json configuration file</span></span><br><span class="line">pm2 <span class="literal">start</span> app.js --<span class="keyword">node</span><span class="title">-args</span>=<span class="string">&quot;--max-old-space-size=1024&quot;</span></span><br><span class="line"></span><br><span class="line">作者：冰冰大象</span><br><span class="line">链接：https://www.jianshu.com/p/<span class="number">6</span>b3b506f7d0a</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于需要hexo-damin支持编写博客，所以需要将hexo服务进行一直开启，但是由于ssh有相关连接限制，又不想修改ssh配置文件，所以出此博客&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    
    <category term="hexo" scheme="https://zhycarge.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Arduino安装教程</title>
    <link href="https://zhycarge.github.io/2021/07/14/esp8266%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhycarge.github.io/2021/07/14/esp8266%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-14T06:37:00.000Z</published>
    <updated>2021-07-15T08:42:04.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下自己安装Arduino的心路历程以及相关过程</p><span id="more"></span><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="什么是Arduino"><a href="#什么是Arduino" class="headerlink" title="什么是Arduino"></a>什么是Arduino</h2><blockquote><p>Arduino是一款便捷灵活、方便上手的开源电子原型平台。包含硬件（各种型号的Arduino板）和软件（IDE）。Arduino能通过各种各样的传感器来感知环境，通过控制灯光、马达和其他的装置来反馈、影响环境。它有着高度分装，方便调用的代码，可以和各类传感器轻松互动，实现我们的创客梦想！<br>知乎  </p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于此软件由国外开发者所开发，因此软件的安装包也在国外地区，不过国内团队已经提供了一个比较好的安装平台为大家进行选择<br><a href="http://www.taichi-maker.com/homepage/download/#software-download">点我</a><br>通过这个方式，能够很好的下载IDE</p><h2 id="配置esp8266的环境"><a href="#配置esp8266的环境" class="headerlink" title="配置esp8266的环境"></a>配置esp8266的环境</h2><p>由于编写是为了编写esp8266，因此我们需要配置它的环境<br>点击<kbd>文件</kbd>—&gt;<kbd>首选项</kbd>，在后面<kbd>附加开发板管理器网址</kbd>处输入以下内容：<br><code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code> 或<br><code>http://wechat.doit.am/package_esp8266com_index.json</code></p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p><img src="/images/pasted-9.png" alt="upload successful"></p><p><img src="/images/pasted-10.png" alt="upload successful"></p><blockquote><p>博主小提醒：<br>由于配置时也是参考了别人的博客，因此测试了一下这两个，发现：<br>第一个需要翻墙进行访问（但是是官方的，会比国内的要很多,虽然会很慢，但是推荐）<br>第二个好像资源已经被删除或者被移动到了其他的地方，将文件地址输入到网站上会显示404界面<br>因此博主采用直接下载的方法进行安装</p></blockquote><p>之后对ide进行重启。之后我们点击<kbd>工具</kbd>—&gt;<kbd>开发板</kbd>—&gt;<kbd>开发板管理器</kbd><br>，在界面中输入esp8266进行搜索安装</p><p><img src="/images/pasted-12.png" alt="upload successful"></p><p><img src="/images/pasted-13.png" alt="upload successful"></p><p><img src="/images/pasted-14.png" alt="upload successful"></p><p>如果发生安装失败的方法，可以看上文，并<a href="#wrong1">点击我来进行跳转</a><br>之后便是重新启动ide软件，会发现esp8266的相关库已经安装成功了</p><p><img src="/images/pasted-15.png" alt="upload successful"></p><h1 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h1><h2 id="通过博客流程无法正常安装esp8266相关库"><a href="#通过博客流程无法正常安装esp8266相关库" class="headerlink" title="通过博客流程无法正常安装esp8266相关库"></a><div id="wrong1">通过博客流程无法正常安装esp8266相关库</div></h2><p>这里提供一个链接，通过<a href="https://www.arduino.cn/thread-76029-1-1.html">点我</a>来进行下载由大佬<code>奈何col</code>所提供的源码。[请注意，此版本为esp8266 2.7版本]<br>下载完成之后双击安装即可</p><h2 id="安装完包之后发现有更新，点击之后相关库消失了"><a href="#安装完包之后发现有更新，点击之后相关库消失了" class="headerlink" title="安装完包之后发现有更新，点击之后相关库消失了"></a>安装完包之后发现有更新，点击之后相关库消失了</h2><p>建议安装完第三方库不要进行更新，因为可能会出现库的匹配问题，有一定几率会删除之前安装的库</p><h2 id="安装过程报错"><a href="#安装过程报错" class="headerlink" title="安装过程报错"></a>安装过程报错</h2><p>这种情况在安装的时候我也出现过，解决方法就是多次点击安装，可能会出现的错误有<code>未通过验证</code>或者<code>在github上未找到相关包</code></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如有其他问题，欢迎留言</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;记录一下自己安装Arduino的心路历程以及相关过程&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://zhycarge.github.io/categories/study/"/>
    
    <category term="硬件" scheme="https://zhycarge.github.io/categories/study/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="esp8266" scheme="https://zhycarge.github.io/tags/esp8266/"/>
    
  </entry>
  
</feed>
